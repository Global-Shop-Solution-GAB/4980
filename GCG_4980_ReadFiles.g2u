Program.Sub.Preflight.Start
V.Global.bHook.Declare
V.Global.bMove.Declare
V.Global.sProcessIDfile.Declare
V.Global.bRead.Declare(Boolean)
V.Global.bImportFail.Declare(Boolean, False)
V.Global.bUnattended.Declare(Boolean, False)
Program.External.Include.Library("GCG_4980_SharedFunctions.lib")
Program.Sub.Preflight.End

Program.Sub.Main.Start
'GCG_4980_ReadFiles.g2u
'Trey S, Ashwin D, Alejandro A
'This script is part of the standard nesting interface. This is the script that reads the drop files
'from the nesting software and prepares them to be posted via the import menu.

F.Intrinsic.Control.Try

F.ODBC.Connection!Con.OpenCompanyConnection
F.Intrinsic.Control.CallSub(LoadProfile)

'check if running from online update
F.Intrinsic.Control.If(V.Caller.Hook,=,38130)
	V.Global.bUnattended.Set(True)
	F.Intrinsic.Control.CallSub(ScriptPIDCheck, "PROJECT", "4980", "TASK", "Import")
F.Intrinsic.Control.EndIf

F.Intrinsic.UI.InvokeWaitDialog("Checking for import files to load.","Nesting Import")

'this is where we are basically checking for each of the import folders associated with the different profiles that one may have saved.
F.Intrinsic.Control.CallSub(FolderAssociationCheck)
F.Intrinsic.Control.CallSub(Exit)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.Main.End

Program.Sub.FolderAssociationCheck.Start
'check for valid profiles/import types

F.Intrinsic.Control.Try

V.Local.iCount.Declare
V.Local.sPath.Declare(String)
V.Local.bFlex.Declare(Boolean, False)

F.Intrinsic.Control.If(V.DataTable.dtProfile.RowCount,=,0)
	'show no profile exists message if its not on line update
	F.Intrinsic.Control.If(V.Caller.Hook,<>,38130)
		F.Intrinsic.UI.Msgbox("You do not have any profiles setup.")
	F.Intrinsic.Control.EndIf
	F.ODBC.Connection!Con.Close
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

F.Intrinsic.control.For(V.Local.iCount,0,V.DataTable.dtProfile.RowCount--,1)
	'based on the path, call the file list sub  where it actually fetches all of the files in the folder path
	F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "CREATE_FLEX_SCHEDULE", "PROFILE", V.DataTable.dtProfile(V.Local.iCount).PROFILE!FieldValTrim)
	F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
		V.Local.bFlex.Set(V.Args.Setting)
	F.Intrinsic.Control.Else
		V.Local.bFlex.Set(False)
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Control.If(V.DataTable.dtProfile(V.Local.iCount).BACK_FLUSH_MAT!FieldVal, =, True, "OR", V.DataTable.dtProfile(V.Local.iCount).BACK_FLUSH_LAB!FieldVal, =, True, V.Local.bFlex, =, True)
		F.Intrinsic.Control.CallSub(FileList,"sReadPath",V.DataTable.dtProfile(V.Local.iCount).IMPORT_FOLDER!FieldValTrim,"sProfile",V.DataTable.dtProfile(V.Local.iCount).PROFILE!FieldVal,"sXPTYPE",V.DataTable.dtProfile(V.Local.iCount).XPTYPE!FieldValTrim,"bRemnant",V.DataTable.dtProfile(V.Local.iCount).REMNANT!FieldVal,"sREMPATH",V.DataTable.dtProfile(V.Local.iCount).REM_FOLDER!FieldValTrim, "Online", V.DataTable.dtProfile(V.Local.iCount).Online_Imp!FieldVal)
		
		'run part separation import
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "PART_SEPARATION", "SETTING", "ENABLED", "PROFILE", V.DataTable.dtProfile(V.Local.iCount).PROFILE!FieldValTrim)
		F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
			F.Intrinsic.Control.If(V.Args.Setting)
				F.Global.General.SetPassedDataElement("PROFILE", V.DataTable.dtProfile(V.Local.iCount).PROFILE!FieldValTrim)
				F.Global.General.SetPassedDataElement("TYPE", V.DataTable.dtProfile(V.Local.iCount).XPTYPE!FieldValTrim)
				
				F.Intrinsic.String.Build("{0}\GCG_4980_PartSeparationImport.g2u", V.Ambient.ScriptPath, V.Local.sPath)
				F.Global.General.CallSyncGAS(V.Local.sPath)
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.EndIf
		
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCount)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.FolderAssociationCheck.End

Program.Sub.LoadProfile.Start
'load profiles and settings

F.Intrinsic.Control.Try

F.Data.DataTable.CreateFromSQL("dtProfile","Con","Select * from GCG_4980_NESTPROFILE where RTRIM(XPTYPE) <> '' and RTRIM(import_folder) <> ''",true)
F.Data.DataTable.CreateFromSQL("RemMapDT","Con","Select * from GCG_4980_REMMAINT ",true)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.LoadProfile.End

Program.Sub.FileList.Start
F.Intrinsic.Control.Try

V.Local.bExists.Declare(Boolean)
V.Local.sReadPath.Declare
V.Local.sReadRemPath.Declare
V.Local.sFileList.Declare(String)
V.Local.sFullName.Declare(String)
V.Local.sRemFullName.Declare(String)
V.Local.sInvalidPath.Declare(String)
V.Local.sInvalidFileName.Declare(String)
V.Local.sMissingAreaPath.Declare(String)
V.Local.sDirectories.Declare(String)
V.Local.sInvalidFilePath.Declare(String)
V.Local.sFile.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.sExtension.Declare(String)
V.Local.bLocked.Declare(Boolean)
V.Local.sMessage.Declare(String)
V.Local.bInvalid.Declare(Boolean, False)
V.Local.sProcessedPath.Declare(String)
V.Local.sProcessedFile.Declare(String)
V.Local.bInString.Declare(Boolean)
V.Local.sLayoutsFile.Declare(String)
V.Local.sPartsFile.Declare(String)
V.Local.sTemp.Declare(String)
V.Local.bLocked2.Declare(Boolean)
V.Local.bNcellStation.Declare(Boolean, False)

'grab options
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "NCELL_STATION_FILE", "PROFILE", V.Args.sProfile)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	V.Local.bNcellStation.Set(V.Args.Setting)
F.Intrinsic.Control.EndIf

' path to move Invalid WO files
F.Intrinsic.String.Build("{0}\InvalidWO\",V.ARGS.sReadPath,V.Local.sInvalidPath)
' path to move Missing Area files
F.Intrinsic.String.Build("{0}\MissingArea\",V.ARGS.sReadPath,V.Local.sMissingAreaPath)
' path to move processed files
F.Intrinsic.String.Build("{0}\Processed\",V.ARGS.sReadPath,V.Local.sProcessedPath)
'path to move invalid files
F.Intrinsic.String.Build("{0}\InvalidFile\",V.ARGS.sReadPath,V.Local.sInvalidFilePath)

F.Intrinsic.String.Build("{0}*!*{1}*!*{2}*!*{3}", V.Local.sInvalidPath, V.Local.sMissingAreaPath, V.Local.sProcessedPath,  V.Local.sInvalidFilePath, V.Local.sDirectories)
F.Intrinsic.Control.CallSub(CheckDirectories, "DIRECTORIES", V.Local.sDirectories)

' check for files in read path
F.Intrinsic.String.Build("{0}\",V.ARGS.sReadPath,V.Local.sReadPath)
F.Intrinsic.String.Build("{0}\",V.ARGS.sREMPATH,V.Local.sReadRemPath)

F.Intrinsic.File.GetFileList(V.Local.sReadPath,V.Local.sFileList)
F.Intrinsic.String.Split(V.Local.sFileList,":",V.Local.sFileList)

F.Intrinsic.Control.If(V.Local.sFileList.Trim, =, "")
	'no files, exit
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sFileList.UBound, 1)
	V.Global.bMove.Set(False)
	V.Local.bInvalid.Set(False)
	V.Global.bImportFail.Set(False)
	F.Intrinsic.File.GetExtensionComponent(V.Local.sFileList(V.Local.iCounter), V.Local.sExtension)
	F.Intrinsic.String.Build("{0}{1}", V.Local.sReadPath, V.Local.sFileList(V.Local.iCounter), V.Local.sFullName)
	F.Intrinsic.String.Build("{0}{1}", V.Local.sInvalidFilePath, V.Local.sFileList(V.Local.iCounter), V.Local.sInvalidFileName)
	F.Intrinsic.File.IsFileLocked(V.Local.sFullName, V.Local.bLocked)
	
	'if it doesn't exist, it may have been moved/deleted or we moved it in the case of metamation
	'either way we don't really care
	F.Intrinsic.File.Exists(V.Local.sFullName, V.Local.bExists)
	F.Intrinsic.Control.If(V.Local.bExists)
		F.Intrinsic.Control.If(V.Local.bLocked)
			F.Intrinsic.String.Build("File {0} is in locked. Unable to read file. Please close the file if you have it open and try again. The file will be skipped for now.", V.Local.sFileList(V.Local.iCounter), V.Local.sMessage)
			F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
			
		F.Intrinsic.Control.Else
			F.Intrinsic.Control.SelectCase(V.Args.sXPTYPE.Trim)
				F.Intrinsic.Control.Case("B")
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "XML")
						'read boost file
						F.Intrinsic.Control.If(V.Args.Online.Not)
							'check if the correct boost file type
							F.Intrinsic.String.IsInString(V.Local.sFileList(V.Local.iCounter), "JobExp", True, V.Local.bInString)
							F.Intrinsic.Control.If(V.Local.bInString)
								F.Intrinsic.Control.CallSub(ReadBXML, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath)
							F.Intrinsic.Control.Else
								V.Local.bInvalid.Set(True)
							F.Intrinsic.Control.EndIf
						F.Intrinsic.Control.Else
							'check if the correct boost file type
							F.Intrinsic.String.IsInString(V.Local.sFileList(V.Local.iCounter), "ProdSheetExp", True, V.Local.bInString)
							F.Intrinsic.Control.If(V.Local.bInString)
								F.Intrinsic.Control.CallSub(ReadBSheetXML, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPORT_PATH", V.Local.sReadPath, "IMPTYPE", V.Args.sXPTYPE)
							F.Intrinsic.Control.Else
								V.Local.bInvalid.Set(True)
							F.Intrinsic.Control.EndIf
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
					
				F.Intrinsic.Control.Case("O")
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "XML")
						'read OPS File
						F.Intrinsic.Control.CallSub(ReadOPSXML, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath)
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("E")
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "CSV")
						F.Intrinsic.Control.CallSub(ReadPep, "sPROFILE", V.Args.sProfile, "sImportFile", V.Local.sFullName, "IMPORT_PATH", V.Local.sReadPath, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE)
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
					
				F.Intrinsic.Control.Case("S")
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "CSV")
						'read sigmanest file
						
						'check if it's a remnant file, shouldn't be in this directory but ?\_(?)_/?
						F.Intrinsic.String.IsInString(V.Local.sFileList(V.Local.iCounter), "Remnant", True, V.Local.bInString)
						F.Intrinsic.Control.If(V.Local.bInString)
							V.Local.bInValid.Set(True)
						F.Intrinsic.Control.Else
							F.Intrinsic.Control.CallSub(ReadMappedNestCSV, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath, "FilePrefix", "", "RemnantFilePrefix", "Remnants_")
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("N")
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "TXT")
						
						'check file name
						F.Intrinsic.String.IsInString(V.Local.sFileList(V.Local.iCounter), "Station", True, V.Local.bInString)
						F.Intrinsic.Control.If(V.Local.bInString)
							F.Intrinsic.Control.If(V.Local.bNcellStation.Not)
								V.Local.bInvalid.Set(True)
							F.Intrinsic.Control.EndIf
						F.Intrinsic.Control.EndIf
						
						'read ncell file
						F.Intrinsic.Control.If(V.Local.bInvalid.Not)
							F.Intrinsic.Control.CallSub(ReadNCELL, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath)
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("M")
					'metamation
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "CSV")
						'metamation has a parts and a layout file, and we need both
						'in the format LAYOUT-JOBID-Parts/Layouts.csv
						F.Intrinsic.String.Split(V.Local.sFileList(V.Local.iCounter), "-", V.Local.sTemp)
						F.Intrinsic.String.Build("{0}{1}-{2}-Layouts.{3}", V.Local.sReadPath, V.Local.sTemp(0), V.Local.sTemp(1), V.Local.sExtension, V.Local.sLayoutsFile)
						F.Intrinsic.String.Build("{0}{1}-{2}-Parts.{3}", V.Local.sReadPath, V.Local.sTemp(0), V.Local.sTemp(1), V.Local.sExtension, V.Local.sPartsFile)
						V.Local.sTemp.Redim(0, 0)
						
						'check both exist
						F.Intrinsic.File.Exists(V.Local.sLayoutsFile, V.Local.bExists)
						F.Intrinsic.Control.If(V.Local.bExists)
							F.Intrinsic.File.Exists(V.Local.sPartsFile, V.Local.bExists)
							F.Intrinsic.Control.If(V.Local.bExists)
								'have to check lock again because there's two files and only one is checked above
								F.Intrinsic.File.IsFileLocked(V.Local.sPartsFile, V.Local.bLocked)
								F.Intrinsic.File.IsFileLocked(V.Local.sLayoutsFile, V.Local.bLocked2)
								
								F.Intrinsic.Control.If(V.Local.bLocked, =, False, AND, V.Local.bLocked2, =, False)
									F.Intrinsic.Control.CallSub(ReadMetamation, "LAYOUT_FILE", V.Local.sLayoutsFile, "PART_FILE", V.Local.sPartsFile, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath)
								F.Intrinsic.Control.Else
									F.Intrinsic.String.Build("File {0} is locked. Unable to read file. Please close the file if you have it open and try again. The file will be skipped for now.", V.Local.sFileList(V.Local.iCounter), V.Local.sMessage)
									F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
								F.Intrinsic.Control.EndIf
							F.Intrinsic.Control.Else
								V.Local.bInValid.Set(True)
							F.Intrinsic.Control.EndIf
						F.Intrinsic.Control.Else
							V.Local.bInValid.Set(True)
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("P")
					'pro nest
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "CSV")
						'read pronest csv
						F.Intrinsic.Control.CallSub(ReadMappedNestCSV, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath, "FilePrefix", "PartsExport", "RemnantFilePrefix", "PlateExport")
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("Y")
					'read Bysoft
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "XML")
						'read bysoft xml
						F.Intrinsic.Control.CallSub(ReadBysoftXML, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath)
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("R")
					'read Radan
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "CSV")
						'read Radan csv
						'need to figure out file prefix
						F.Intrinsic.Control.CallSub(ReadMappedNestCSV, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath, "FilePrefix", "", "RemnantFilePrefix", "")
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.Case("U")
					'read cutrite
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "PTX")
						'read cutrite ptx file
						F.Intrinsic.Control.CallSub(ReadCutRite, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath)
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
					
				F.Intrinsic.Control.Case("D")
					'cad
				F.Intrinsic.Control.Case("C")
					'custom CSV
					F.Intrinsic.Control.If(V.Local.sExtension.UCase.Trim, =, "CSV")
						F.Intrinsic.Control.CallSub(ReadMappedNestCSV, "ImportFile", V.Local.sFullName, "PROFILE", V.Args.sProfile, "IMPTYPE", V.Args.sXPTYPE, "IMPORT_PATH", V.Local.sReadPath, "FilePrefix", "", "RemnantFilePrefix", "")
					F.Intrinsic.Control.Else
						V.Local.bInvalid.Set(True)
					F.Intrinsic.Control.EndIf
					
					
				F.Intrinsic.Control.Case("A")
					'dr abe
					
			F.Intrinsic.Control.EndSelect
		F.Intrinsic.Control.EndIf
		
		F.Intrinsic.Control.If(V.Local.bInvalid)
			'move to invalid file directory
			F.Intrinsic.String.Build("File {0} is an ivalid file for this import. The file will be moved to {1}.", V.Local.sFileList(V.Local.iCounter), V.Local.sInvalidFilePath, V.Local.sMessage)
			F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
			F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sFullName, "NEW_PATH", V.Local.sInvalidFilePath)
		F.Intrinsic.Control.ElseIf(V.Global.bMove)
			'it may have already been moved
			F.Intrinsic.File.Exists(V.Local.sFullName, V.Local.bExists)
			F.Intrinsic.Control.If(V.Local.bExists)
				'have to move both files for metamation
				F.Intrinsic.Control.If(V.Args.sXPTYPE.Trim, =, "M")
	
					'move part file
					F.Intrinsic.File.GetFileNameFromFQN(V.Local.sPartsFile, V.Local.sTemp)
					F.Intrinsic.String.Replace(V.Local.sTemp, V.Local.sExtension, "", V.Local.sProcessedFile)
					F.Intrinsic.String.Replace(V.Local.sProcessedFile, ".", "", V.Local.sProcessedFile)
					F.Intrinsic.String.Build("{0}_{1}.{2}", V.Local.sProcessedFile, V.Ambient.Now.FormatYYYYMMDDHHNNSS, V.Local.sExtension, V.Local.sProcessedFile)
					F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sPartsFile, "NEW_PATH", V.Local.sProcessedPath, "NEW_NAME", V.Local.sProcessedFile)
					
					'move layout file
					F.Intrinsic.File.GetFileNameFromFQN(V.Local.sLayoutsFile, V.Local.sTemp)
					F.Intrinsic.String.Replace(V.Local.sTemp, V.Local.sExtension, "", V.Local.sProcessedFile)
					F.Intrinsic.String.Replace(V.Local.sProcessedFile, ".", "", V.Local.sProcessedFile)
					F.Intrinsic.String.Build("{0}_{1}.{2}", V.Local.sProcessedFile, V.Ambient.Now.FormatYYYYMMDDHHNNSS, V.Local.sExtension, V.Local.sProcessedFile)
					F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sLayoutsFile, "NEW_PATH", V.Local.sProcessedPath, "NEW_NAME", V.Local.sProcessedFile)
					
					V.Local.sTemp.Redim(0, 0)
	
				F.Intrinsic.Control.Else
					F.Intrinsic.String.Replace(V.Local.sFileList(V.Local.iCounter), V.Local.sExtension, "", V.Local.sProcessedFile)
					F.Intrinsic.String.Replace(V.Local.sProcessedFile, ".", "", V.Local.sProcessedFile)
					F.Intrinsic.String.Build("{0}_{1}.{2}", V.Local.sProcessedFile, V.Ambient.Now.FormatYYYYMMDDHHNNSS, V.Local.sExtension, V.Local.sProcessedFile)
					F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sFullName, "NEW_PATH", V.Local.sProcessedPath, "NEW_NAME", V.Local.sProcessedFile)
				F.Intrinsic.Control.EndIf
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.FileList.End

Program.Sub.ReadCutRite.Start
F.Intrinsic.Control.Try

V.Local.sFile.Declare(String)
V.Local.bExists.Declare(Boolean, False)
V.Local.sImportFields.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.sDataTable.Declare(String)
V.Local.sDataTables.Declare(String)
V.Local.iBound.Declare(Long, 0)
V.Local.sContent.Declare(String)
V.Local.sRow.Declare(String)
V.Local.sTempDataTable.Declare(String)
V.Local.sFields.Declare(String)
V.Local.sTypes.Declare(String, "String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String")
V.Local.sTypeTemp.Declare(String)
V.Local.sThisRow.Declare(String)
V.Local.sCurrentTypes.Declare(String)
V.Local.sField.Declare(String)
V.Local.sSQL.Declare(String)
V.Local.sTotalSheetAreaColumn.Declare(String)
V.Local.sTotalJobAreaColumn.Declare(String)
V.Local.sExpression.Declare(String)
V.Local.sProgramNumberColumn.Declare(String)
V.Local.sPartWeightColumn.Declare(String)
V.Local.sFilter.Declare(String)
V.Local.sPrograms.Declare(String)
V.Local.sJob.Declare(String)
V.Local.iNestCounter.Declare(Long)
V.Local.sTempSplit.Declare(String)
V.Local.bInString.Declare(Boolean)
V.Local.iJobCounter.Declare(Long)
V.Local.sJobs.Declare(String)
V.Local.fArea.Declare(Float)
V.Local.fWeight.Declare(Float)
V.Local.fJobArea.Declare(Float)
V.Local.iJobs.Declare(Long)
V.Local.fTime.Declare(Float)
V.Local.sEmployeeColumn.Declare(String)
V.Local.sNewNestID.Declare(String)

'pull in import field list
F.Intrinsic.String.Build("{0}\GCG_4980_CutRiteImportFields.dat", V.Ambient.ScriptPath, V.Local.sFile)
F.Intrinsic.File.Exists(V.Local.sFile, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists.Not)
	F.Intrinsic.UI.Msgbox("Error: Missing Cut Rite import field file [GCG_4980_CutRiteImportFields.dat].")
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

F.Intrinsic.File.File2String(V.Local.sFile, V.Local.sImportFields)
F.Data.DataTable.CreateFromString("dtCutRiteImportFields", V.Local.sImportFields, "Table*!*Field", "String*!*String", ".", V.Ambient.NewLine)
F.Intrinsic.Control.If(V.DataTable.dtCutRiteImportFields(V.DataTable.dtCutRiteImportFields.RowCount--).Field!FieldValTrim, =, "")
		F.Data.DataTable.DeleteRow("dtCutRiteImportFields", V.DataTable.dtCutRiteImportFields.RowCount--)
F.Intrinsic.Control.EndIf

'create datatables
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtCutRiteImportFields.RowCount--, 1)
	F.Intrinsic.String.Build("dtCutRite{0}", V.DataTable.dtCutRiteImportFields(V.Local.iCounter).TABLE!FieldValtrim, V.Local.sDataTable)
	F.Intrinsic.Control.If(V.DataTable.[V.Local.sDataTable].Exists, =, False)
		F.Data.DataTable.Create(V.Local.sDataTable, True)
		
		F.Intrinsic.String.Build("{0}.TABLE", V.DataTable.dtCutRiteImportFields(V.Local.iCounter).TABLE!FieldValtrim, V.Local.sField)
		F.Data.DataTable.AddColumn(V.Local.sDataTable, V.Local.sField, "String", V.DataTable.dtCutRiteImportFields(V.Local.iCounter).TABLE!FieldValtrim)
		
		F.Intrinsic.Control.If(V.Local.sDataTables(V.Local.iBound).Trim, =, "")
			V.Local.sDataTables.Set(V.Local.sDataTable)
		F.Intrinsic.Control.Else
			F.Intrinsic.Math.Add(V.Local.sDataTables.UBound, 1, V.Local.iBound)
			V.Local.sDataTables.RedimPreserve(0, V.Local.iBound)
			V.Local.sDataTables(V.Local.iBound).Set(V.Local.sDataTable)
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.String.Build("{0}.{1}", V.DataTable.dtCutRiteImportFields(V.Local.iCounter).TABLE!FieldValtrim, V.DataTable.dtCutRiteImportFields(V.Local.iCounter).FIELD!FieldValtrim, V.Local.sField)
	F.Data.DataTable.AddColumn(V.Local.sDataTable, V.Local.sField, "String")
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Data.DataTable.Close("dtCutRiteImportFields")

'read in file to datatables
F.Intrinsic.File.File2String(V.Args.ImportFile, V.Local.sContent)
F.Intrinsic.String.RegExReplace(V.Local.sContent, "  +", "", True, True, V.Local.sContent)
F.Intrinsic.String.Split(V.Local.sContent, V.Ambient.NewLine, V.Local.sContent)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sContent.UBound, 1)
	F.Intrinsic.String.Split(V.Local.sContent(V.Local.iCounter), ",", V.Local.sRow)
	
	'HEADER - general information describing the complete data structure (or file)
	'JOBS - header data for each job (cutting list or optimised run)
	'PARTS_REQ - basic requirement details for each item in the cutting list
	'PARTS_INF - standard information about each part
	'PARTS_UDI - user-defined information about each part
	'PARTS_DST - destacking information about each part
	'BOARDS - information about each item in the board (stock) list
	'MATERIALS – information about each material type
	'NOTES - other information for a job
	'OFFCUTS - record describing each off-cut produced
	'PATTERNS - pattern header records - one for each cutting pattern
	'PTN_UDI - information used to match parts in a strip - one for each strip in the pattern
	'CUTS - cutting instructions – occur many times per pattern – once for each cut required
	'VECTORS – vector graphics describing the pattern
	F.Intrinsic.Control.SelectCase(V.Local.sRow(0))
		'not reading OFFCUTS, PTN_UDI, VECTORS
		F.Intrinsic.Control.CaseAny("HEADER", "JOBS", "PARTS_REQ", "PARTS_UDI", "BOARDS", "MATERIALS", "CUTS", "PARTS_INF", "PARTS_DST", "PATTERNS", "NOTES")
			F.Intrinsic.String.Build("dtCutRite{0}", V.Local.sRow(0), V.Local.sDataTable)
		
			'build field list
			F.Intrinsic.String.Split(V.DataTable.[V.Local.sDataTable].FieldNames, "*!*", V.Local.sFields)
			V.Local.sRow.RedimPreserve(0, V.Local.sFields.UBound)
			F.Intrinsic.String.Join(V.Local.sRow, "*!*", V.Local.sThisRow)
			
			'build type list
			F.Intrinsic.String.Split(V.Local.sTypes, "*!*", V.Local.sTypeTemp)
			V.Local.sTypeTemp.RedimPreserve(0, V.Local.sFields.UBound)
			F.Intrinsic.String.Join(V.Local.sTypeTemp, "*!*", V.Local.sCurrentTypes)
			
			'grab line
			F.Data.DataTable.CreateFromString("dtTemp", V.Local.sThisRow, V.DataTable.[V.Local.sDataTable].FieldNames, V.Local.sCurrentTypes, "*!*", "***NO-DELIMITER***")
			F.Data.DataTable.Merge("dtTemp", V.Local.sDataTable, False, 2)
			F.Data.DataTable.Close("dtTemp")
	F.Intrinsic.Control.EndSelect
F.Intrinsic.Control.Next(V.Local.iCounter)
V.Local.sTypes.Redim(0, 0)
V.Local.sRow.Redim(0, 0)
V.Local.sContent.Redim(0, 0)

'now we have all the data, join it up
'join parts table
F.Data.Linq.Join("LeftJoin", "DataTable", "dtCutRitePARTS_REQ*!*A", "DataTable", "dtCutRitePARTS_UDI*!*B", "A.PARTS_REQ.PART_INDEX = B.PARTS_UDI.PART_INDEX", "DataTable", "dtCutritePARTS_DST*!*C", "A.PARTS_REQ.PART_INDEX = C.PARTS_DST.PART_INDEX", "DataTable", "dtCutritePARTS_INF*!*D", "A.PARTS_REQ.PART_INDEX = D.PARTS_INF.PART_INDEX", "*", "", "", "", "dtCutRiteParts", True)

'fill in cutrite job data
F.Intrinsic.Control.CallSub(FillDataTableToDataTable, "SOURCE_KEYS", "JOBS.Job_Index", "TARGET_KEYS", "PARTS_REQ.Job_Index", "TARGET_DATATABLE", "dtCutRiteParts", "SOURCE_DATATABLE", "dtCutRiteJOBS", "CLOSE_SOURCE", False)

'fill it cutrite notes data
F.Intrinsic.Control.CallSub(FillDataTableToDataTable, "SOURCE_KEYS", "NOTES.Job_Index", "TARGET_KEYS", "PARTS_REQ.Job_Index", "TARGET_DATATABLE", "dtCutRiteParts", "SOURCE_DATATABLE", "dtCutRiteNOTES", "CLOSE_SOURCE", False)

'fill in cutrite header data
F.Data.DataTable.AddColumn("dtCutRiteHEADER", "HEADER.JOIN_KEY", String, "0")
F.Data.DataTable.AddColumn("dtCutRiteParts", "PARTS_REQ.JOIN_KEY", String, "0")
F.Intrinsic.Control.CallSub(FillDataTableToDataTable, "SOURCE_KEYS", "HEADER.JOIN_KEY", "TARGET_KEYS", "PARTS_REQ.JOIN_KEY", "TARGET_DATATABLE", "dtCutRiteParts", "SOURCE_DATATABLE", "dtCutRiteHEADER", "CLOSE_SOURCE", False)

'get cut lines with a part
F.Data.Linq.Join("LeftJoin", "DataTable", "dtCutRiteParts*!*A", "DataTable", "dtCutriteCuts*!*B", "A.PARTS_REQ.PART_INDEX = B.CUTS.PART_INDEX", "DataTable", "dtCutritePATTERNS*!*C", "B.CUTS.PTN_INDEX = C.PATTERNS.PTN_INDEX", "DataTable", "dtCutriteBOARDS*!*D", "C.PATTERNS.BRD_INDEX = D.BOARDS.BRD_INDEX", "DataTable", "dtCutriteMATERIALS*!*E", "D.BOARDS.MAT_INDEX = E.MATERIALS.MAT_INDEX", "*", "", "", "", "dtCutriteFinal", True)
F.Data.DataTable.Close("dtCutriteParts")

'also fill in default board from material
F.Data.Dictionary.CreateFromDataTable("dictTemp", "dtCutriteBOARDS", "BOARDS.MAT_INDEX", "BOARDS.INFORMATION")
F.Data.Dictionary.SetDefaultReturn("dictTemp", "")
F.Data.DataTable.AddColumn("dtCutriteFinal", "MAIN_MATERIAL", "String", "")
F.Data.DataTable.FillFromDictionary("dtCutriteFinal", "dictTemp", "MATERIALS.MAT_INDEX", "MAIN_MATERIAL")
F.Data.Dictionary.Close("dictTemp")

F.Intrinsic.Control.CallSub(AddExtraImportFields, "Profile", V.Args.Profile, "DataTable", "dtCutRiteFinal")

F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "OFFCUT", "Boolean", "IIF(SUBSTRING([BOARDS.CODE], 1, 1) = 'X', True, False)")

'close other DTs
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sDataTables.UBound, 1)
	F.Intrinsic.Control.If(V.DataTable.[V.Local.sDataTables(V.Local.iCounter)].Exists)
		F.Data.DataTable.Close(V.Local.sDataTables(V.Local.iCounter))
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)

'now process the mapping
'at the moment, most of the mapping is stored as columns in GCG_4980_NESTPROFILE
'some is stored as rows in GCG_4980_SETTINGS
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "JOB_AREA", "PROFILE", V.Args.PROFILE)
V.Local.sTotalJobAreaColumn.Set(V.Args.Setting.Trim)
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "SHEET_AREA", "PROFILE", V.Args.PROFILE)
V.Local.sTotalSheetAreaColumn.Set(V.Args.Setting.Trim)
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "PROGRAM_NUMBER", "PROFILE", V.Args.PROFILE)
V.Local.sProgramNumberColumn.Set(V.Args.Setting.Trim)
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "PART_WEIGHT", "PROFILE", V.Args.PROFILE)
V.Local.sPartWeightColumn.Set(V.Args.Setting.Trim)
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "EMPLOYEE_ID", "PROFILE", V.Args.PROFILE)
V.Local.sEmployeeColumn.Set(V.Args.Setting.Trim)

'make sure we have the profile data
F.Intrinsic.String.Build("PROFILE = '{0}'", V.Args.Profile, V.Local.sFilter)
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile.Exists)
	F.Data.DataView.SetFilter("dtProfile", "dvProfile", V.Local.sFilter)
F.Intrinsic.Control.Else
	F.Data.Dataview.Create("dtProfile", "dvProfile", 22, V.Local.sFilter, "")
F.Intrinsic.Control.EndIf

'add conversion columns
'nest id
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).NEST_ID!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).NEST_ID!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_NEST_ID", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_NEST_ID", "String", "")
F.Intrinsic.Control.EndIf

'job
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).WO_NUMBER!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).WO_NUMBER!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_WORK_ORDER", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_WORK_ORDER", "String", "")
F.Intrinsic.Control.EndIf

'material
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).RAW_MAT!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("IIF(TRIM([{0}]) = '', TRIM([MAIN_MATERIAL]), TRIM([{0}]))", V.DataView.dtProfile!dvProfile(0).RAW_MAT!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_MATERIAL", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_MATERIAL", "String", "")
F.Intrinsic.Control.EndIf

'material location
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).MAT_LOCATION!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).MAT_LOCATION!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_MATERIAL_LOCATION", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_MATERIAL_LOCATION", "String", "")
F.Intrinsic.Control.EndIf

'workcenter
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).LABOR_WC!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).LABOR_WC!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_WORKCENTER", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_WORKCENTER", "String", "")
F.Intrinsic.Control.EndIf

'area per part
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).AREA_P_PART!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("IIF([OFFCUT], 0, IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double')))", V.DataView.dtProfile!dvProfile(0).AREA_P_PART!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_AREA_PER_PART", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_AREA_PER_PART", "Float", 0)
F.Intrinsic.Control.EndIf

'sheet weight
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).MAT_WEIGHT!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("IIF([OFFCUT], 0, IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double')))", V.DataView.dtProfile!dvProfile(0).MAT_WEIGHT!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_SHEET_WEIGHT", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_SHEET_WEIGHT", "Float", 0)
F.Intrinsic.Control.EndIf

'good pieces
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).GOOD_PC!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).GOOD_PC!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_GOOD_PIECES", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_GOOD_PIECES", "Float", 0)
F.Intrinsic.Control.EndIf

'Bad pieces
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).BAD_PC!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).BAD_PC!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_BAD_PIECES", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_BAD_PIECES", "Float", 0)
F.Intrinsic.Control.EndIf

'time per part
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).TIME_PER_PART!FieldValTrim, !=, "")
	F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).TIME_PER_PART!FieldValTrim, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_TIME_PER_PART", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_TIME_PER_PART", "Float", 0)
F.Intrinsic.Control.EndIf

'total job area
F.Intrinsic.Control.If(V.Local.sTotalJobAreaColumn, !=, "")
	F.Intrinsic.String.Build("IIF([OFFCUT], 0, IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double')))", V.Local.sTotalJobAreaColumn, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_TOTAL_JOB_AREA", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_TOTAL_JOB_AREA", "Float", 0)
F.Intrinsic.Control.EndIf

'sheet area
F.Intrinsic.Control.If(V.Local.sTotalSheetAreaColumn, !=, "")
	F.Intrinsic.String.Build("IIF([OFFCUT], 0, IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double')))", V.Local.sTotalSheetAreaColumn, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_SHEET_AREA", "Float", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_SHEET_AREA", "Float", 0)
F.Intrinsic.Control.EndIf

'program number
F.Intrinsic.Control.If(V.Local.sProgramNumberColumn, !=, "")
	F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sProgramNumberColumn, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_PROGRAM_NUMBER", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_PROGRAM_NUMBER", "String", "")
F.Intrinsic.Control.EndIf

'part weight
F.Intrinsic.Control.If(V.Local.sPartWeightColumn, !=, "")
	F.Intrinsic.String.Build("IIF([OFFCUT], 0, IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double')))", V.Local.sPartWeightColumn, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_PART_WEIGHT", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_PART_WEIGHT", "String", "")
F.Intrinsic.Control.EndIf

'employee ID
F.Intrinsic.Control.If(V.Local.sEmployeeColumn, !=, "")
	F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sEmployeeColumn, V.Local.sExpression)
	F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_EMPLOYEE_ID", "String", V.Local.sExpression)
F.Intrinsic.Control.Else
	F.Data.DataTable.AddColumn("dtCutRiteFinal", "IMPORT_EMPLOYEE_ID", "String", "")
F.Intrinsic.Control.EndIf

'add calculated columns
F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "FINAL_IMPORT_QUANTITY", "Float", "[IMPORT_GOOD_PIECES] + [IMPORT_BAD_PIECES]")
F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_TOTAL_TIME", "Float", "[FINAL_IMPORT_QUANTITY] * [IMPORT_TIME_PER_PART]")
F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_SHEET_COUNT", "Float", "IIF(TRIM(IsNull([BOARDS.QTY_USED], '')) = '', CONVERT('0', 'System.Double'), CONVERT([BOARDS.QTY_USED], 'System.Double'))")

'sigmanest comes in as hours, others usually minutes
F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "IMPORT_TOTAL_TIME_HOURS", "Float", "[IMPORT_TOTAL_TIME] / 60")

'create the DataTables we'll use to import
F.Intrinsic.Control.CallSub(CreateImportDataTables)

F.Data.Datatable.AddColumn("dtCutRiteFinal", "IMPORT_WORK_ORDER_FINAL", "String", "")

'set final job/material
'grab the last untaken job for each reacord...
F.Data.DataView.Create("dtCutRiteFinal", "dvCutRiteFinal", 22)
F.Data.DataView.ToDataTableDistinct("dtCutRiteFinal", "dvCutRiteFinal", "dtCutriteList", "IMPORT_MATERIAL*!*IMPORT_WORK_ORDER")

F.Data.DataTable.AddColumn("dtCutriteList", "WORK_ORDERS", "String", "")
F.Data.DataTable.CopyColumn("dtCutriteList", "IMPORT_WORK_ORDER", "WORK_ORDERS")

'set the final job on each record, since they are passing multiple jobs for each part and we only want to use each once
F.Data.DataView.Create("dtCutriteList", "dvCutriteList", 22)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtCutriteList.RowCount--, 1)
	'okay, but what happens if there is no job
	F.Intrinsic.String.Split(V.DataTable.dtCutriteList(V.Local.iCounter).WORK_ORDERS!FieldValTrim, "*!*", V.Local.sJobs)
	V.Local.sJob.Set(V.Local.sJobs(0))
	F.Intrinsic.String.Replace(V.Local.sJob, "*!*", "", V.Local.sJob)
	F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sJobs, 0, V.Local.sJobs)
	'F.Intrinsic.Variable.PopArray(V.Local.sJobs, V.Local.sJobs)
	F.Intrinsic.String.Join(V.Local.sJobs, "*!*", V.Local.sJobs)
	
	F.Intrinsic.String.Build("[WORK_ORDERS] = '{0}'", V.DataTable.dtCutriteList(V.Local.iCounter).WORK_ORDERS!FieldValTrim, V.Local.sFilter)
	F.Data.DataView.SetFilter("dtCutriteList", "dvCutriteList", V.Local.sFilter)
	F.Data.DataView.SetValue("dtCutriteList", "dvCutriteList", -1, "WORK_ORDERS", V.Local.sJobs)
	
	F.Intrinsic.String.Build("[IMPORT_MATERIAL] = '{0}' and [IMPORT_WORK_ORDER] = '{1}'", V.DataTable.dtCutriteList(V.Local.iCounter).IMPORT_MATERIAL!FieldValTrim, V.DataTable.dtCutriteList(V.Local.iCounter).IMPORT_WORK_ORDER!FieldValTrim, V.Local.sFilter)
	F.Data.DataView.SetFilter("dtCutRiteFinal", "dvCutRiteFinal", V.Local.sFilter)
	F.Data.DataView.SetValue("dtCutRiteFinal", "dvCutRiteFinal", -1, "IMPORT_WORK_ORDER_FINAL", V.Local.sJob)
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Data.DataView.Close("dtCutriteList", "dvCutriteList")
F.Data.DataTable.Close("dtCutriteList")
V.Local.sJobs.Redim(0, 0)

'clear any 0 material records
F.Data.DataTable.CopyColumn("dtCutriteFinal", "IMPORT_MATERIAL", "FINAL_MATERIAL", True)
F.Data.DataView.SetFilter("dtCutRiteFinal", "dvCutRiteFinal", "IMPORT_MATERIAL = ''")
F.Data.DataView.SetValue("dtCutRiteFinal", "dvCutRiteFinal", -1, "FINAL_MATERIAL", V.DataTable.dtCutRiteFinal(0).IMPORT_MATERIAL!FieldValTrim)
F.Data.DataView.Close("dtCutriteFinal", "dvCutRiteFinal")

'okay so there can be multiple materials so we need to split them into multiple nests
F.Data.DataTable.AddExpressionColumn("dtCutRiteFinal", "NEST_ID_MATERIAL_KEY", "String", "IMPORT_NEST_ID + FINAL_MATERIAL")

'get the number of nests to loop through
F.Data.DataTable.ColumnToString("dtCutRiteFinal", "NEST_ID_MATERIAL_KEY", V.Local.sPrograms)
F.Intrinsic.String.Split(V.Local.sPrograms, "*!*", V.Local.sPrograms)
F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sPrograms, V.Local.sPrograms)

F.Data.DataView.Create("dtCutRiteFinal", "dvCutRiteFinal", 22)
F.Intrinsic.Control.For(V.Local.iNestCounter, 0, V.Local.sPrograms.UBound, 1)
	F.Intrinsic.String.Build("NEST_ID_MATERIAL_KEY = '{0}'", V.Local.sPrograms(V.Local.iNestCounter), V.Local.sFilter)
	F.Data.DataView.SetFilter("dtCutRiteFinal", "dvCutRiteFinal", V.Local.sFilter)
	
	'create new nest ID
	F.Intrinsic.String.Build("{0}-{1}", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(0).IMPORT_NEST_ID!FieldValTrim, V.Local.iNestCounter, V.Local.sNewNestID)
	
	'add row to material datatable for the material used
	F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Local.sNewNestID, "SHEET_MATERIAL", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(0).FINAL_MATERIAL!FieldValTrim, "SHEET_LOCATION", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(0).IMPORT_MATERIAL_LOCATION!FieldValTrim, "SHEET_AREA_SQUARE_INCHES", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(0).IMPORT_SHEET_AREA!FieldValFloat, "SHEET_COUNT", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(0).IMPORT_SHEET_COUNT!FieldValFloat, "SHEET_WEIGHT_POUNDS", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(0).IMPORT_SHEET_WEIGHT!FieldValFloat)
	
	'grab job data
	F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Dataview.dtCutRiteFinal!dvCutRiteFinal.RowCount--, 1)
		F.Intrinsic.Control.If(V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_WORK_ORDER_FINAL!FieldValTrim, !=, "")
			'grab job from multiple
			F.Intrinsic.String.Split(V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_WORK_ORDER_FINAL!FieldValTrim, "*!*", V.Local.sJobs)
			F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sJobs, V.Local.sJobs)
			F.Intrinsic.Control.If(V.Local.sJobs(V.Local.sJobs.UBound).Trim, =, "", AND, V.Local.sJobs.UBound, >, 0)
				F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sJobs, V.Local.sJobs.UBound, V.Local.sJobs)
			F.Intrinsic.Control.EndIf
			
			F.Intrinsic.Math.Add(V.Local.sJobs.UBound, 1, V.Local.iJobs)
			
			F.Intrinsic.Control.For(V.Local.iJobCounter, 0, V.Local.sJobs.UBound, 1)
				F.Intrinsic.Control.If(V.Local.sJobs(V.Local.iJobCounter).Trim, !=, "")
					'grab job number
					F.Intrinsic.String.Split(V.Local.sJobs(V.Local.iJobCounter), "-", V.Local.sJob)
					V.Local.sJob.RedimPreserve(0, 2)
					
					'sometimes sequence is delimited with :
					F.Intrinsic.String.IsInString(V.Local.sJob(1), ":", True, V.Local.bInString)
					F.Intrinsic.Control.If(V.Local.bInString)
						F.Intrinsic.String.Split(V.Local.sJob(1), ":", V.Local.sTempSplit)
						V.Local.sTempSplit.RedimPreserve(0, 1)
						V.Local.sJob(1).Set(V.Local.sTempSplit(0))
						V.Local.sJob(2).Set(V.Local.sTempSplit(1))
						V.Local.sTempSplit.Redim(0, 0)
					F.Intrinsic.Control.EndIf
					
					'so since we may be importing multiple jobs from one row, we need to determine the numbers
					'good pieces should stay the same, bad we can ignore for now, weight and material and time I think we need to divide?
					F.Intrinsic.Math.Div(V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_TOTAL_TIME_HOURS!FieldValFloat, V.Local.iJobs, V.Local.fTime)
					F.Intrinsic.Math.Div(V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_AREA_PER_PART!FieldValFloat, V.Local.iJobs, V.Local.fArea)
					F.Intrinsic.Math.Div(V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_TOTAL_JOB_AREA!FieldValFloat, V.Local.iJobs, V.Local.fJobArea)
					F.Intrinsic.Math.Div(V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_PART_WEIGHT!FieldValFloat, V.Local.iJobs, V.Local.fWeight)
					
					F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.Local.sNewNestID, "JOB", V.Local.sJob(0).Trim, "SUFFIX", V.Local.sJob(1).Trim, "SEQUENCE", V.Local.sJob(2).Trim, "TOTAL_TIME_HOURS", V.Local.fTime, "GOOD_PIECES", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_GOOD_PIECES!FieldValFloat, "BAD_PIECES", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_BAD_PIECES!FieldValFloat, "PART_AREA_SQUARE_INCHES", V.Local.fArea, "WC", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_WORKCENTER!FieldValTrim, "WORK_ORDER_MATERIAL_USED", V.Local.fJobArea, "PART_WEIGHT_POUNDS", V.Local.fWeight, "RUN_COUNT", 1, "EMPLOYEE", V.Dataview.dtCutRiteFinal!dvCutRiteFinal(V.Local.iCounter).IMPORT_EMPLOYEE_ID!FieldValTrim)
					
					V.Local.sJob.Redim(0, 0)
				F.Intrinsic.Control.EndIf
			F.Intrinsic.Control.Next(V.Local.iJobCounter)
			V.Local.sJobs.Redim(0, 0)
		F.Intrinsic.Control.EndIf
		
	F.Intrinsic.Control.Next(V.Local.iCounter)
F.Intrinsic.Control.Next(V.Local.iNestCounter)
V.Local.sPrograms.Redim(0, 0)
F.Data.DataView.Close("dtCutRiteFinal", "dvCutRiteFinal")
F.Data.DataTable.Close("dtCutRiteFinal")

F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)
V.Global.bMove.Set(True)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadCutRite.End

Program.Sub.FillDataTableToDataTable.Start
'pass keys, *!* 								- SOURCE_KEYS
'pass keys, *!* 								- TARGET_KEYS
'pass main DT 									- TARGET_DATATABLE
'pass second dt 								- SOURCE_DATATABLE
'optionally pass types, otherwise strings, *!* 	- TYPES
'optionally pass to close source				- CLOSE_SOURCE

'could maybe do this better using dataviews and distinct datatables
'set all values at once

V.Local.sKeys.Declare(String)
V.Local.iCounter.Declare(String)
V.Local.sExpression.Declare(String)
V.Local.sFields.Declare(String)
V.Local.sColumn.Declare(String)
V.Local.bInString.Declare(Boolean, False)
V.Local.sTypes.Declare(String, "")
V.Local.sType.Declare(String, "")
V.Local.bExists.Declare(Boolean)

F.Intrinsic.String.Split(V.DataTable.[V.Args.SOURCE_DATATABLE].FieldNames, "*!*", V.Local.sFields)

F.Intrinsic.Variable.ArgExists("TYPES", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	F.Intrinsic.String.Split(V.Args.Types, "*!*", V.Local.sTypes)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Split(V.Args.SOURCE_KEYS, "*!*", V.Local.sKeys)
F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sKeys(0), V.Local.sExpression)
F.Intrinsic.Control.For(V.Local.iCounter, 1, V.Local.sKeys.UBound, 1)
	F.Intrinsic.String.Build("{0} + TRIM([{1}])", V.Local.sExpression, V.Local.sKeys(V.Local.iCounter), V.Local.sExpression)
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Intrinsic.String.Join(V.Local.sKeys, "!@#$%%$#@!", V.Local.sKeys)
F.Intrinsic.String.Build("!@#$%%$#@!{0}!@#$%%$#@!", V.Local.sKeys, V.Local.sKeys)
F.Data.DataTable.AddExpressionColumn(V.Args.SOURCE_DATATABLE, "FILL_KEY", "String", V.Local.sExpression)

F.Intrinsic.String.Split(V.Args.TARGET_KEYS, "*!*", V.Local.sKeys)
F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sKeys(0), V.Local.sExpression)
F.Intrinsic.Control.For(V.Local.iCounter, 1, V.Local.sKeys.UBound, 1)
	F.Intrinsic.String.Build("{0} + TRIM([{1}])", V.Local.sExpression, V.Local.sKeys(V.Local.iCounter), V.Local.sExpression)
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Intrinsic.String.Join(V.Local.sKeys, "!@#$%%$#@!", V.Local.sKeys)
F.Intrinsic.String.Build("!@#$%%$#@!{0}!@#$%%$#@!", V.Local.sKeys, V.Local.sKeys)
F.Data.DataTable.AddExpressionColumn(V.Args.TARGET_DATATABLE, "FILL_KEY", "String", V.Local.sExpression)

F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sFields.UBound, 1)

	F.Intrinsic.String.Build("!@#$%%$#@!{0}!@#$%%$#@!", V.Local.sFields(V.Local.iCounter), V.Local.sColumn)
	F.Intrinsic.String.IsInString(V.Local.sKeys, V.Local.sColumn, True, V.Local.bInString)
	
	F.Intrinsic.Control.If(V.Local.bInString.Not)
		F.Data.Dictionary.CreateFromDataTable("dictFillTemp", V.Args.SOURCE_DATATABLE, "FILL_KEY", V.Local.sFields(V.Local.iCounter))
		V.Local.sType.Set(V.Local.sTypes(V.Local.iCounter).UCASE)
		
		F.Intrinsic.Control.SelectCase(V.Local.sType)
			F.Intrinsic.Control.CaseAny("LONG", "FLOAT")
				F.Data.Dictionary.SetDefaultReturn("dictFillTemp", 0)
			F.Intrinsic.Control.Case("DATE")
				F.Data.Dictionary.SetDefaultReturn("dictFillTemp", "1900-01-01")
			F.Intrinsic.Control.Case("BOOLEAN")
				F.Data.Dictionary.SetDefaultReturn("dictFillTemp", False)
			F.Intrinsic.Control.CaseElse
				F.Data.Dictionary.SetDefaultReturn("dictFillTemp", "")
				V.Local.sType.Set("String")
		F.Intrinsic.Control.EndSelect
		
		F.Data.DataTable.AddColumn(V.Args.TARGET_DATATABLE, V.Local.sFields(V.Local.iCounter), V.Local.sType)
		F.Data.DataTable.FillFromDictionary(V.Args.TARGET_DATATABLE, "dictFillTemp", "FILL_KEY", V.Local.sFields(V.Local.iCounter))
		F.Data.Dictionary.Close("dictFillTemp")
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)

F.Data.DataTable.RemoveColumn(V.Args.SOURCE_DATATABLE, "FILL_KEY")
F.Data.DataTable.RemoveColumn(V.Args.TARGET_DATATABLE, "FILL_KEY")

F.Intrinsic.Variable.ArgExists("CLOSE_SOURCE", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	F.Intrinsic.Control.If(V.Args.CLOSE_SOURCE)
		F.Data.DataTable.Close(V.Args.SOURCE_DATATABLE)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf
Program.Sub.FillDataTableToDataTable.End

Program.Sub.ReadNCell.Start
'read NCELL csv file and import

'sample file format
'#,(N)estID, Total Sheets, Thk , Den
'N,1043,8,0.0590,0.283
'#,(M)aterial,WC,SheetID,SheetQty,SheetX,SheetY,SheetUsedX,SheetUsedY
'M,P2-200-14,1_MC3,104301,1,120,60,117.09,58.34
'M,P2-200-14,1_MC3,104302,1,120,60,64.21,58.34
'M,P2-200-14,1_MC3,104303,1,120,60,64.21,58.34
'M,P2-200-14,1_MC3,104304,1,120,60,64.21,58.34
'M,P2-200-14,1_MC3,104305,1,120,60,64.21,58.34
'M,P2-200-14,1_MC3,104306,1,120,60,64.21,58.34
'M,P2-200-14,1_MC3,104307,1,120,60,64.21,58.34
'M,P2-200-14,1_MC3,104308,1,120,60,64.21,29.73
'#,(P)art Start , Part End , Part Start Date , Part End Date , Part Time Hr , Material , Part , Part Order , Seq , WC , FinQty , PartShtAlloc , Weight , Lot 
'P,13:05:56,13:16:45,05/15/19,05/15/19,0.180,P2-200-14,170479,304755-003-000200,,LSR0,15,107.084,1.788,
'P,13:16:45,13:20:35,05/15/19,05/15/19,0.064,P2-200-14,170505,304793-001-000200,,LSR0,2,80.367,1.342,
'P,13:20:35,13:23:42,05/15/19,05/15/19,0.052,P2-200-14,143912,304763-002-000200,,LSR0,1,72.315,1.207,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:38:07,05/15/19,05/15/19,0.240,P2-200-14,170478,304755-002-000200,,LSR0,6,4176.702,69.738,
'P,13:23:42,13:30:54,05/15/19,05/15/19,0.120,P2-200-14,170478,304755-002-000200,,LSR0,3,2088.353,34.872,
'#,(D)rops
'D,P2-200-14,60X56,104302
'D,P2-200-14,60X56,104303
'D,P2-200-14,60X56,104304
'D,P2-200-14,60X56,104305
'D,P2-200-14,60X56,104306
'D,P2-200-14,60X56,104307
'D,P2-200-14,60X56,104308

F.Intrinsic.Control.Try

V.Local.sSegments.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sNestID.Declare(String)
V.Local.iSheets.Declare(Long)
V.Local.fThickness.Declare(Float)
V.Local.fDensity.Declare(Float)
V.Local.sSection.Declare(String)
V.Local.sFields.Declare(String)
V.Local.sTypes.Declare(String)
V.Local.sMaterial.Declare(String)
V.Local.fSheetlength.Declare(Float)
V.Local.fSheetWidth.Declare(Float)
V.Local.fSheetArea.Declare(Float)
V.Local.iCounter.Declare(Long)
V.Local.fTime.Declare(Float)
V.Local.fQuantity.Declare(Float)
V.Local.sFilter.Declare(String)
V.Local.sJob.Declare(String)
V.Local.fAreaSum.Declare(Float)
V.Local.fPartArea.Declare(Float)
V.Local.sSize.Declare(String)
V.Local.sInvalidPath.Declare(String)
V.Local.iSegmentCounter.Declare(Long)
V.Local.sCurrentSegment.Declare(String)
V.Local.sSegmentType.Declare(String)
V.Local.fWeightSum.Declare(Float)
V.Local.fPartWeight.Declare(Float)
V.Local.sLineTest.Declare(String)
V.Local.sFieldTest.Declare(String)
V.Local.bInString.Declare(Boolean, False)
V.Local.bStation.Declare(Boolean, False)
V.Local.sSQL.Declare(String)

V.Global.bMove.Set(True)

'for All Metals, if it's a station file we're going to:
'1. Ignore material
'2. Pull sequence from WC
F.Intrinsic.String.IsInString(V.Args.ImportFile, "Station", True, V.Local.bStation)

'create the import data tables
F.Intrinsic.Control.CallSub(CreateImportDataTables)

'get the data from the file
F.Intrinsic.File.File2String(V.Args.ImportFile, V.Local.sFile)
F.Intrinsic.String.Split(V.Local.sFile, "#", V.Local.sSegments)

F.Intrinsic.Control.If(V.Local.sSegments.UBound, =, 0)
	V.Global.bMove.Set(False)
	'move to invalid folder
	F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'loop through the segments and process them, start from 1 to ignore empty string before #
'can be multiple nests, but they should always have their segments listed together in order NMPD
'currently this will accept any order, and assumes that any section belongs to the last nest section that preceeded it

F.Intrinsic.Control.For(V.Local.iSegmentCounter, 1, V.Local.sSegments.UBound, 1)
	V.Local.sCurrentSegment.Set(V.Local.sSegments(V.Local.iSegmentCounter))
	
	V.Local.sSegmentType.Set(V.Local.sCurrentSegment.Left4)
	F.Intrinsic.Control.SelectCase(V.Local.sSegmentType)
		F.Intrinsic.Control.Case(",(N)")
		
			'get nest info
			V.Local.sSection.Set(V.Local.sCurrentSegment)
			F.Intrinsic.String.Split(V.Local.sSection, V.Ambient.NewLine, V.Local.sSection)
			F.Intrinsic.String.Split(V.Local.sSection(1), ",", V.Local.sSection)
			V.Local.sNestID.Set(V.Local.sSection(1))
			
			'for all metals we need to ignore this, they are doing sheet by sheet
			'V.Local.iSheets.Set(V.Local.sSection(2))
			V.Local.iSheets.Set(1)
			V.Local.fThickness.Set(V.Local.sSection(3))
			V.Local.fDensity.Set(V.Local.sSection(4))
			
		F.Intrinsic.Control.Case(",(M)")
			
			'get sheet info
			'currently we only accept one material type per nest, so we really just need the top row
			F.Intrinsic.Control.If(V.Local.sNestID.Trim, =, "")
				'invalid file, move to invalid folder
				V.Global.bMove.Set(False)
				F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
				F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
				F.Intrinsic.Control.ExitSub
			F.Intrinsic.Control.EndIf
			
			V.Local.sFields.Set("Type*!*Material*!*WC*!*SHEET_ID*!*SHEET_QTY*!*SheetX*!*SheetY*!*SheetUsedX*!*SheetUsedY")
			V.Local.sTypes.Set("String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String")
			F.Data.DataTable.CreateFromString("dtNcellSheets", V.Local.sCurrentSegment, V.Local.sFields, V.Local.sTypes, ",", V.Ambient.NewLine)
			
			'one header row, one blank row
			F.Intrinsic.Control.If(V.DataTable.dtNcellSheets.RowCount, <=, 2)
				V.Global.bMove.Set(False)
				'move to invalid folder
				F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
				F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
				F.Intrinsic.Control.ExitSub
			F.Intrinsic.Control.EndIf
			
			F.Data.DataTable.DeleteRow("dtNcellSheets", V.DataTable.dtNcellSheets.RowCount--)
			F.Data.DataTable.DeleteRow("dtNcellSheets", 0)
			
			V.Local.sMaterial.Set(V.DataTable.dtNcellSheets(0).MATERIAL!FieldValTrim)
			V.Local.fSheetlength.Set(V.DataTable.dtNcellSheets(0).SheetX!FieldValFloat)
			V.Local.fSheetWidth.Set(V.DataTable.dtNcellSheets(0).SheetY!FieldValFloat)
			F.Intrinsic.Math.Mult(V.Local.fSheetlength, V.Local.fSheetWidth, V.Local.fSheetArea)
			
			F.Data.DataTable.Close("dtNcellSheets")
			
			'add to global datatable
			F.Intrinsic.Control.If(V.Local.sMaterial.Trim, !=, "")
				F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Local.sNestID, "SHEET_MATERIAL", V.Local.sMaterial, "SHEET_LOCATION", "", "SHEET_AREA_SQUARE_INCHES", V.Local.fSheetArea, "SHEET_COUNT", V.Local.iSheets, "SHEET_WEIGHT_POUNDS", 0)
			F.Intrinsic.Control.EndIf
			
		F.Intrinsic.Control.Case(",(P)")
			
			'get part/wo info
			F.Intrinsic.Control.If(V.Local.sNestID.Trim, =, "")
				'invalid file, move to invalid folder
				V.Global.bMove.Set(False)
				F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
				F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
				F.Intrinsic.Control.ExitSub
			F.Intrinsic.Control.EndIf
						
			F.Intrinsic.String.Split(V.Local.sCurrentSegment, V.Ambient.NewLine, V.Local.sLineTest)
			F.Intrinsic.String.Split(V.Local.sLineTest(0), ",", V.Local.sFieldTest)
			F.Intrinsic.Control.If(V.Local.sFieldTest.UBound, =, 16)
				V.Local.sFields.Set("Type*!*PartStart*!*PartEnd*!*PartStartDate*!*PartEndDate*!*PartTimeHr*!*Material*!*Part*!*PartOrder*!*Seq*!*WC*!*FinQty*!*ScrapQty*!*ScrapCode*!*PartShtAlloc*!*Weight*!*Lot")
				V.Local.sTypes.Set("String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String")
			F.Intrinsic.Control.Else
				V.Local.sFields.Set("Type*!*PartStart*!*PartEnd*!*PartStartDate*!*PartEndDate*!*PartTimeHr*!*Material*!*Part*!*PartOrder*!*Seq*!*WC*!*FinQty*!*PartShtAlloc*!*Weight*!*Lot")
				V.Local.sTypes.Set("String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*String")
			F.Intrinsic.Control.EndIf
			V.Local.sLineTest.Redim(0, 0)
			V.Local.sFieldTest.Redim(0, 0)
			
			F.Data.DataTable.CreateFromString("dtNcellParts", V.Local.sCurrentSegment, V.Local.sFields, V.Local.sTypes, ",", V.Ambient.NewLine)
			
			'one header row, one blank row
			F.Intrinsic.Control.If(V.DataTable.dtNcellParts.RowCount, <=, 2)
				V.Global.bMove.Set(False)
				'move to invalid folder
				F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
				F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
				F.Intrinsic.Control.ExitSub
			F.Intrinsic.Control.EndIf
			
			F.Data.DataTable.DeleteRow("dtNcellParts", V.DataTable.dtNcellParts.RowCount--)
			F.Data.DataTable.DeleteRow("dtNcellParts", 0)
			
			F.Data.DataTable.AddExpressionColumn("dtNcellParts", "TIME_FLOAT", "Float", "CONVERT([PartTimeHr], 'System.Double')")
			F.Data.DataTable.AddExpressionColumn("dtNcellParts", "QUANTITY_FLOAT", "Float", "CONVERT([FinQty], 'System.Double')")
			F.Data.DataTable.AddExpressionColumn("dtNcellParts", "AREA_FLOAT", "Float", "CONVERT([PartShtAlloc], 'System.Double')")
			F.Data.DataTable.AddExpressionColumn("dtNcellParts", "WEIGHT_FLOAT", "Float", "CONVERT([Weight], 'System.Double')")
			
			'loop through work orders, sum up info for them
			F.Data.DataView.Create("dtNcellParts", "dvNcellParts", 22)
			F.Data.DataView.ToDataTableDistinct("dtNcellParts", "dvNcellParts", "dtDistinctWOs", "PartOrder")
			
			F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtDistinctWOs.RowCount--, 1)
				F.Intrinsic.String.Build("[PartOrder] = '{0}'", V.DataTable.dtDistinctWOs(V.Local.iCounter).PartOrder!FieldValTrim, V.Local.sFilter)
				
				F.Data.DataTable.Compute("dtNcellParts", "Sum(TIME_FLOAT)", V.Local.sFilter, V.Local.fTime)
				F.Data.DataTable.Compute("dtNcellParts", "Sum(QUANTITY_FLOAT)", V.Local.sFilter, V.Local.fQuantity)
				F.Data.DataTable.Compute("dtNcellParts", "Sum(AREA_FLOAT)", V.Local.sFilter, V.Local.fAreaSum)
				F.Data.DataTable.Compute("dtNcellParts", "Sum(WEIGHT_FLOAT)", V.Local.sFilter, V.Local.fWeightSum)
				F.Intrinsic.Math.Div(V.Local.fAreaSum, V.Local.fQuantity, V.Local.fPartArea)
				F.Intrinsic.Math.Div(V.Local.fWeightSum, V.Local.fQuantity, V.Local.fPartWeight)
				
				V.Local.sJob.Set(V.DataTable.dtDistinctWOs(V.Local.iCounter).PartOrder!FieldValTrim)
				
				F.Data.DataView.SetFilter("dtNcellParts", "dvNcellParts", V.Local.sFilter)
				
				'add to global datatable
				F.Intrinsic.Control.If(V.Local.sJob.Trim, !=, "")
					F.Intrinsic.String.Split(V.Local.sJob, "-", V.Local.sJob)
					
					'if station file, grab sequence from WC
					'not currently accounting for WC XREF...
					F.Intrinsic.Control.If(V.Local.bStation)
						F.Intrinsic.String.Build("select top 1 RTRIM(SEQ) from V_JOB_OPERATIONS where JOB = '{0}' and SUFFIX = '{1}' and PART = '{2}'", V.Local.sJob(0).Trim, V.Local.sJob(1).Trim, V.DataView.dtNcellParts!dvNcellParts(0).WC!FieldValTrim, V.Local.sSQL)
						F.ODBC.Connection!Con.ExecuteAndReturn(V.Local.sSQL, V.Local.sSQL)
						F.Intrinsic.Control.If(V.Ambient.ExecuteAndReturnEOF.Not)
							V.Local.sJob(2).Set(V.Local.sSQL)
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.EndIf
					
					F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.Local.sNestID, "JOB", V.Local.sJob(0), "SUFFIX", V.Local.sJob(1), "SEQUENCE", V.Local.sJob(2), "TOTAL_TIME_HOURS", V.Local.fTime, "GOOD_PIECES", V.Local.fQuantity, "BAD_PIECES", 0, "PART_AREA_SQUARE_INCHES", V.Local.fPartArea, "PART_WEIGHT_POUNDS", V.Local.fPartWeight, "WC", V.DataView.dtNcellParts!dvNcellParts(0).WC!FieldValTrim, "WORK_ORDER_MATERIAL_USED", 0)
				F.Intrinsic.Control.EndIf
			F.Intrinsic.Control.Next(V.Local.iCounter)
			
			F.Data.DataView.Close("dtNcellParts", "dvNcellParts")
			F.Data.DataTable.Close("dtDistinctWOs")
			F.Data.DataTable.Close("dtNcellParts")
		
		F.Intrinsic.Control.Case(",(D)")
	
			'get drop info
			F.Intrinsic.Control.If(V.Local.sNestID.Trim, =, "")
				'invalid file, move to invalid folder
				V.Global.bMove.Set(False)
				F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
				F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
				F.Intrinsic.Control.ExitSub
			F.Intrinsic.Control.EndIf
			
			F.Intrinsic.String.Split(V.Local.sCurrentSegment, V.Ambient.NewLine, V.Local.sLineTest)
			F.Intrinsic.Control.If(V.Local.sLineTest.UBound, >, 1)
				
				'the headers don't match the data, so we use the data line to test
				F.Intrinsic.String.Split(V.Local.sLineTest(1), ",", V.Local.sFieldTest)
				F.Intrinsic.Control.If(V.Local.sFieldTest.UBound, =, 4)
					V.Local.sFields.Set("Type*!*Material*!*Size*!*DropID*!*Weight")
					V.Local.sTypes.Set("String*!*String*!*String*!*String*!*String")
				F.Intrinsic.Control.ElseIf(V.Local.sFieldTest.UBound, =, 7)
					V.Local.sFields.Set("Type*!*Material*!*Y*!*X*!*StockID*!*DropID*!*Weight")
					V.Local.sTypes.Set("String*!*String*!*String*!*String*!*String*!*String*!*String")
				F.Intrinsic.Control.Else
					V.Local.sFields.Set("Type*!*Material*!*Size*!*DropID")
					V.Local.sTypes.Set("String*!*String*!*String*!*String")
				F.Intrinsic.Control.EndIf
				V.Local.sFieldTest.Redim(0, 0)
				
				F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sLineTest, 0, V.Local.sLineTest)
				F.Intrinsic.String.Join(V.Local.sLineTest, V.Ambient.NewLine, V.Local.sCurrentSegment)
				F.Data.DataTable.CreateFromString("dtNcellDrops", V.Local.sCurrentSegment, V.Local.sFields, V.Local.sTypes, ",", V.Ambient.NewLine)
				V.Local.sLineTest.Redim(0, 0)
				
				F.Intrinsic.String.IsInString(V.DataTable.dtNcellDrops.FieldNames, "Size", True, V.Local.bInString)
				F.Intrinsic.Control.If(V.Local.bInString.Not)
					F.Data.DataTable.AddExpressionColumn("dtNcellDrops", "Size", "String", "Convert([X], 'System.String') + 'X' + Convert([Y], 'System.String')")
				F.Intrinsic.Control.EndIf
			
				'one header row, one blank row
				F.Intrinsic.Control.If(V.DataTable.dtNcellDrops.RowCount, >, 2)
					F.Data.DataTable.DeleteRow("dtNcellDrops", V.DataTable.dtNcellDrops.RowCount--)
					'dealing with the header above
					'F.Data.DataTable.DeleteRow("dtNcellDrops", 0)
					
					F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtNcellDrops.RowCount--, 1)
						V.Local.sSize.Set(V.DataTable.dtNcellDrops(V.Local.iCounter).Size!FieldValTrim)
						F.Intrinsic.String.Split(V.Local.sSize, "X", V.Local.sSize)
						
						'add to global datatable
						F.Intrinsic.Control.If(V.DataTable.dtNcellDrops(V.Local.iCounter).DROPID!FieldValTrim, !=, "")
							F.Data.DataTable.AddRow("dtDrops", "NEST_ID", V.Local.sNestID, "DROP_ID", V.DataTable.dtNcellDrops(V.Local.iCounter).DROPID!FieldValTrim, "DROP_LENGTH_INCHES", V.Local.sSize(0), "DROP_WIDTH_INCHES", V.Local.sSize(1), "DROP_WEIGHT_POUNDS", 0)
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.Next(V.Local.iCounter)
					
					F.Data.DataTable.Close("dtNcellDrops")
				F.Intrinsic.Control.EndIf
			F.Intrinsic.Control.EndIf
			
		F.Intrinsic.Control.CaseElse
			'invalid file, move to invalid folder
			V.Global.bMove.Set(False)
			F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
			F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
			F.Intrinsic.Control.ExitSub
			
	F.Intrinsic.Control.EndSelect
	
F.Intrinsic.Control.Next(V.Local.iSegmentCounter)
				
F.Intrinsic.Control.If(V.Local.bStation)
	F.Data.DataTable.SetValue("dtMaterial", -1, "SHEET_COUNT", 0)
	F.Data.DataTable.SetValue("dtWorkOrders", -1, "PART_AREA_SQUARE_INCHES", 0)
F.Intrinsic.Control.EndIf

'use the data added in the import tables to run the checks and import the nest
F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadNCell.End

Program.Sub.ReadPep.Start
V.Local.sFilter.Declare
V.Local.sFilePath.Declare
V.Local.bExists.Declare
V.Local.sFiles.Declare
V.Local.sSingleFileName.Declare
V.Local.sText.Declare
V.Local.iCnt.Declare
V.Local.sTemp.Declare
V.Local.sTempField.Declare
V.Local.sFieldTitles.Declare
V.Local.sFieldTypes.Declare
V.Local.sSQL.Declare
V.Local.sNest_ID.Declare
V.Local.sWo_Number.Declare
V.Local.sRaw_Mat.Declare
V.Local.sQTY.Declare
V.Local.sArea_P_Part.Declare
V.Local.sDate_Processed.Declare
V.Local.sTime_Per_Part.Declare
V.Local.sWorkCG.Declare
V.Local.sLabor_WC.Declare
V.Local.sGood_PC.Declare
V.Local.sBad_PC.Declare
V.Local.sExpresionSubstring.Declare
V.Local.sJobAreaSquare.Declare
V.Local.sPartAreaSquareInches.Declare
V.Local.fSheets.Declare
V.Local.sRaw_Mat_SheetArea.Declare
V.Local.sRaw_Mat_Weight.Declare
V.Local.sNest_ID_Record.Declare
V.Local.sWo_Number_Record.Declare
V.Local.sRaw_Mat_Record.Declare
V.Local.iQTY_Record.Declare
V.Local.fArea_P_Part_Record.Declare
V.Local.fArea_P_Job_Record.Declare
V.Local.sDate_Processed_Record.Declare
V.Local.fTime_Per_Part_Record.Declare
V.Local.sWorkCG_Record.Declare
V.Local.sLabor_WC_Record.Declare
V.Local.iGood_PC_Record.Declare
V.Local.iBad_PC_Record.Declare
V.Local.sJob_Record.Declare
V.Local.sSuffix_Record.Declare
V.Local.sSeq_Record.Declare
V.Local.fRaw_Width.Declare
V.Local.fRaw_Length.Declare
V.Local.fRaw_Area.Declare
V.Local.fJobAreaSquare_Record.Declare
V.Local.fFG_Width.Declare
V.Local.fFG_Length.Declare
V.Local.fFG_Area.Declare
V.Local.fPartAreaSquareInches_Record.Declare
V.Local.fRaw_Mat_SheetArea_Record.Declare
V.Local.fRaw_Mat_Weight_Record.Declare
V.Local.sEmployeeColumn.Declare(String)
V.Local.sEmployee.Declare(String)

F.Intrinsic.Control.Try
	
	V.Global.bMove.Set(true)
	
	'Gets the Import Folder
	F.Intrinsic.String.Build("Select * from GCG_4980_NESTPROFILE where PROFILE = '{0}'", V.Args.sProfile, V.Local.sSQL)
	F.Data.DataTable.CreateFromSQL("pepDT", "con", V.Local.sSQL, true)

	F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "JOB_AREA", "PROFILE", V.Args.PROFILE)
	V.Local.sJobAreaSquare.Set(V.Args.Setting.Trim)
	F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "SHEET_AREA", "PROFILE", V.Args.PROFILE)
	V.Local.sRaw_Mat_SheetArea.Set(V.Args.Setting.Trim)
	F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "EMPLOYEE_ID", "PROFILE", V.Args.PROFILE)
	V.Local.sEmployeeIDColumn.Set(V.Args.Setting.Trim)

	F.Intrinsic.Control.If(V.Local.sJobAreaSquare.Trim, =, "")
		V.Local.sJobAreaSquare.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Control.If(V.Local.sRaw_Mat_SheetArea.Trim, =, "")
		V.Local.sRaw_Mat_SheetArea.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Control.If(V.Local.sEmployeeIDColumn.Trim, =, "")
		V.Local.sEmployeeIDColumn.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	'Create Dictionary
	V.Local.sNest_ID.Set(V.DataTable.pepDT(0).Nest_ID!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sNest_ID.Trim, =, "")
		V.Local.sNest_ID.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	V.Local.sWo_Number.Set(V.DataTable.pepDT(0).Wo_Number!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sWo_Number.Trim, =, "")
		V.Local.sWo_Number.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	V.Local.sRaw_Mat.Set(V.DataTable.pepDT(0).Raw_Mat!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sRaw_Mat.Trim, =, "")
		V.Local.sRaw_Mat.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
'	V.Local.sQTY.Set(V.DataTable.pepDT(0).QTY!FieldValTrim)
'	F.Intrinsic.Control.If(V.Local.sQTY.Trim, =, "")
'		V.Local.sQTY.Set("blankColInt")
'	F.Intrinsic.Control.EndIf
	
	V.Local.sArea_P_Part.Set(V.DataTable.pepDT(0).AREA_P_PART!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sArea_P_Part.Trim, =, "")
		V.Local.sArea_P_Part.Set("blankColInt")
	F.Intrinsic.Control.EndIf
	
	V.Local.sDate_Processed.Set(V.DataTable.pepDT(0).Date_Processed!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sDate_Processed.Trim, =, "")
		V.Local.sDate_Processed.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	V.Local.sTime_Per_Part.Set(V.DataTable.pepDT(0).Time_Per_Part!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sTime_Per_Part.Trim, =, "")
		V.Local.sTime_Per_Part.Set("blankColInt")
	F.Intrinsic.Control.EndIf
	
'	V.Local.sWorkCG.Set(V.DataTable.pepDT(0).WorkCG!FieldValTrim)
'	F.Intrinsic.Control.If(V.Local.sWorkCG.Trim, =, "")
'		V.Local.sWorkCG.Set("blankCol")
'	F.Intrinsic.Control.EndIf
	
	V.Local.sLabor_WC.Set(V.DataTable.pepDT(0).Labor_WC!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sLabor_WC.Trim, =, "")
		V.Local.sLabor_WC.Set("blankCol")
	F.Intrinsic.Control.EndIf
	
	V.Local.sGood_PC.Set(V.DataTable.pepDT(0).GOOD_PC!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sGood_PC.Trim, =, "")
		V.Local.sGood_PC.Set("blankColInt")
	F.Intrinsic.Control.EndIf
	
	V.Local.sBad_PC.Set(V.DataTable.pepDT(0).BAD_PC!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sBad_PC.Trim, =, "")
		V.Local.sBad_PC.Set("blankColInt")
	F.Intrinsic.Control.EndIf
	
	V.Local.sRaw_Mat_Weight.Set(V.DataTable.pepDT(0).Mat_Weight!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sRaw_Mat_Weight.Trim, =, "")
		V.Local.sRaw_Mat_Weight.Set("blankColInt")
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Control.If(V.DataTable.pepDT.RowCount, =, 1)
		V.Local.sFilePath.Set(V.DataTable.pepDT(0).Import_Folder!FieldValTrim)
		V.Local.sFieldTitles.Set(V.DataTable.pepDT(0).IMP_FMAP!FieldValTrim)
	F.Intrinsic.Control.EndIf
	
	V.Local.sPartAreaSquareInches.Set(V.DataTable.pepDT(0).AREA_P_PART!FieldValTrim)
	F.Intrinsic.Control.If(V.Local.sPartAreaSquareInches.Trim, =, "")
		V.Local.sPartAreaSquareInches.Set("blankColInt")
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.String.SplitCSV(V.Local.sFieldTitles, V.Local.sTempField)
	
	F.Intrinsic.Control.For(V.Local.iCnt, 0, V.Local.sTempField.UBound, 1)
		F.Intrinsic.Control.If(V.Local.sFieldTypes.Trim, =, "")
			V.Local.sFieldTypes.Set("String")
		F.Intrinsic.Control.Else
			F.Intrinsic.String.Build("{0}*!*String", V.Local.sFieldTypes, V.Local.sFieldTypes)
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.Next(V.Local.iCnt)
		
	V.Local.sTempField.Redim(0,0)
	F.Intrinsic.String.Replace(V.Local.sFieldTitles, ",", "*!*", V.Local.sFieldTitles)
	
	F.Intrinsic.String.Build("{0}\", V.Local.sFilePath.Trim, V.Local.sFilePath)
'******************************************'
'Get single file path from File List
	'Get File List
	F.Intrinsic.File.DirExists(V.Local.sFilePath, V.Local.bExists)
	F.Intrinsic.Control.If(V.Local.bExists)
		F.Data.DataTable.CreateFromCSV("pepImportDT", V.Args.sImportFile, V.Local.sFieldTitles, V.Local.sFieldTypes, true)
	F.Intrinsic.Control.EndIf

	F.Data.DataTable.DeleteRow("pepImportDT", 0)
	F.Data.DataTable.AcceptChanges("pepImportDT")
	
	F.Data.DataTable.AddColumn("pepImportDT", "blankCol", "String")
	F.Data.DataTable.AddColumn("pepImportDT", "blankColInt", "Long", 0)
	
	F.Intrinsic.Control.CallSub(CreateImportDataTables)
	F.Intrinsic.Control.CallSub(AddExtraImportFields, "Profile", V.Args.Profile, "DataTable", "pepImportDT")
	'CHange v local to database row.

	F.Intrinsic.Control.For(V.Local.iCnt, 0, V.DataTable.pepImportDT.RowCount--, 1)
		
		V.Local.sNest_ID_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sNest_ID]!FieldValTrim)
		'V.Local.iQTY_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sQTY]!FieldVal)
		V.Local.fArea_P_Part_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sArea_P_Part]!FieldVal)
		V.Local.sDate_Processed_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sDate_Processed]!FieldValTrim)
		V.Local.fTime_Per_Part_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sTime_Per_Part]!FieldValTrim)
		'V.Local.sWorkCG_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sWorkCG]!FieldValTrim)
		V.Local.sLabor_WC_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sLabor_WC]!FieldValTrim)
		V.Local.iGood_PC_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sGood_PC]!FieldVal)
		V.Local.iBad_PC_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sBad_PC]!FieldVal)
		V.Local.fArea_P_Job_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sJobAreaSquare]!FieldVal)
		V.Local.sEmployee.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sEmployeeColumn]!FieldVal)
		
		V.Local.sJob_Record.Set(V.DataTable.pepImportDT(V.Local.iCnt).[V.Local.sWo_Number]!FieldVal)
		F.Intrinsic.String.Split(V.Local.sJob_Record, "-", V.Local.sJob_Record)
		V.Local.sSuffix_Record.Set(V.Local.sJob_Record(1).Trim)
		V.Local.sSeq_Record.Set(V.Local.sJob_Record(2).Trim)
		V.Local.sJob_Record.Set(V.Local.sJob_Record(0).Trim)
		
		F.Data.DataTable.AddRow("dtWorkOrders", "Nest_ID", V.Local.sNest_ID_Record, "Job", V.Local.sJob_Record, "Suffix", V.Local.sSuffix_Record, "Sequence", V.Local.sSeq_Record, "Total_Time_Hours", V.Local.fTime_Per_Part_Record, "GOOD_PIECES", V.Local.iGood_PC_Record, "BAD_PIECES", V.Local.iBad_PC_Record, "Part_Area_Square_Inches", V.Local.fArea_P_Part_Record, "WC", V.Local.sLabor_WC_Record, "WORK_ORDER_MATERIAL_USED", V.Local.fArea_P_Job_Record, "EMPLOYEE", V.Local.sEmployee)

	F.Intrinsic.Control.Next(V.Local.iCnt)

	F.Intrinsic.String.Build("{0} <> ''", V.Local.sNest_ID, V.Local.sTemp)
	F.Data.DataView.Create("pepImportDT", "pepImportDV", 22, V.Local.sTemp, "")

	F.Data.DataView.ToDataTable("pepImportDT", "pepImportDV", "singleRawMatDT")
	F.Intrinsic.Control.If(V.DataTable.singleRawMatDT.RowCount, >, 0)
	
		F.Data.DataTable.AddExpressionColumn("singleRawMatDT", "SheetCount_Exp", "Float", "Convert(WOSheetUsed, 'System.Double')")
		V.Local.sTemp.Set("Sum(SheetCount_Exp)")
		F.Data.DataTable.Compute("singleRawMatDT", V.Local.sTemp, "", V.Local.fSheets)
		F.Intrinsic.Math.Round(V.Local.fSheets, 0, V.Local.fSheets)
		
		V.Local.sNest_ID_Record.Set(V.DataTable.singleRawMatDT(0).[V.Local.sNest_ID]!FieldValTrim)
		V.Local.fRaw_Mat_SheetArea_Record.Set(V.DataTable.singleRawMatDT(0).[V.Local.sRaw_Mat_SheetArea]!FieldVal)
		V.Local.fRaw_Mat_Weight_Record.Set(V.DataTable.singleRawMatDT(0).[V.Local.sRaw_Mat_Weight]!FieldVal)
		V.Local.sRaw_Mat_Record.Set(V.DataTable.singleRawMatDT(0).[V.Local.sRaw_Mat]!FieldValTrim)
		F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Local.sNest_ID_Record, "SHEET_MATERIAL", V.Local.sRaw_Mat_Record, "SHEET_AREA_SQUARE_INCHES", V.Local.fRaw_Mat_SheetArea_Record, "SHEET_COUNT", V.Local.fSheets, "SHEET_WEIGHT_POUNDS", V.Local.fRaw_Mat_Weight_Record, "SHEET_LOCATION", "")
		
	F.Intrinsic.Control.EndIf
	F.Data.DataView.Close("pepImportDT", "pepImportDV")
	F.Data.DataTable.Close("pepDT")
	F.Data.DataTable.Close("pepImportDT")
	
	F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.sPROFILE, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.sImportFile, "TYPE", V.Args.ImpType)
	
F.Intrinsic.Control.Catch
	V.Global.bMove.Set(False)
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadPep.End

Program.Sub.ReadBXML.Start
'read boost XML file, import

F.Intrinsic.Control.Try

V.Local.fNegHours.Declare(Float)
V.Local.sDoc.Declare(String)
V.Local.sBound.Declare(String)
V.Local.sStartTime.Declare(String)
V.Local.sEndTime.Declare(String)
V.Local.dStartTime.Declare(Date)
V.Local.dEndTime.Declare(Date)
V.Local.bEOF.Declare(Boolean,false)
V.Local.bEOF1.Declare(Boolean,false)
V.Local.bEOF2.Declare(Boolean,false)
V.Local.bEOF3.Declare(Boolean,false)
V.Local.sWC.Declare(String)
V.Local.sNestID.Declare(String)
V.Local.sJob.Declare(String)
V.Local.sTJob.Declare(String)
V.Local.fRunShtAr.Declare(Float)
V.Local.fShtAr.Declare(Float)
V.Local.fTotShtAr.Declare(Float,0)
V.Local.fTotDropAr.Declare(Float,0)
V.Local.iCount.Declare(Long)
V.Local.iRemLine.Declare(Long)
V.Local.fTime.Declare(Float)
V.Local.fRemLength.Declare(Float)
V.Local.fRemWidth.Declare(Float)
V.Local.fRemWeight.Declare(Float)
V.Local.fQty.Declare(Float)
V.Local.fQtyStdAln.Declare(Float)
V.Local.sSQL.Declare(String)
V.Local.sOrderName.Declare(String)
V.Local.sMaterial.Declare(String)
V.Local.sMatRem.Declare(String)
V.Local.sSize.Declare(String)
V.Local.sType.Declare(String)
V.Local.sRemL.Declare(String)
V.Local.sRemW.Declare(String)
V.Local.sRemWt.Declare(String)
V.Local.sOutInvalid.Declare
V.Local.fTotalOASheets.Declare(Float)
V.Local.fTotalSheets.Declare(Float)
V.Local.sRemSheets.Declare(String)
V.Local.fPartLength.Declare(Float)
V.Local.fPartWidth.Declare(Float)
V.Local.fPartWeight.Declare(Float)
V.Local.fIssueTotal.Declare(Float)
V.Local.fLength.Declare(Float)
V.Local.fWeight.Declare(Float)
V.Local.fWidth.Declare(Float)
V.Local.fIssueAr.Declare(Float)
V.Local.fTotIssueAr.Declare(Float,0)
V.Local.fTotalArea.Declare(Float)
V.Static.iDocumentCount.Declare(Long)
V.Local.iCount3.Declare(Long)
V.Local.iID.Declare(Long)
V.Local.iDID.Declare(Long)
V.Local.iMID.Declare(Long)
V.Local.fHours.Declare(Float)
V.Local.sFilter.Declare(String)
V.Local.sDropID.Declare(String)

V.Global.bMove.Set(True)

'create the datatables to import with
F.Intrinsic.Control.CallSub(CreateImportDataTables)

F.Intrinsic.Math.Add(V.Static.iDocumentCount,1,V.Static.iDocumentCount)
F.Intrinsic.String.Build("Trumpf{0}",V.Static.iDocumentCount,V.Local.sDoc)

'loads the xml document
F.Global.XML.LoadDocument(V.Local.sDoc,V.Args.ImportFile,False,True,False,False)

'checks to see what the tag after PPSExport is and runs based on the file.
F.Global.XML.Query(V.Local.sDoc,"Type","/*/*",False)
F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"Type","nodeName",V.Local.sType)

F.Intrinsic.Control.If(V.Local.sType,=,"JobFeedback")
	'set variable to true so it will process it
	V.Global.bRead.Set(True)
	'Reads JobExp#.xml
	'runs query on xml to grab all of the NestIDs in Jobname attribute of JobFeedback
	F.Global.XML.Query(V.Local.sDoc,"NestID","//JobFeedback/@Jobname",False)
	
	F.Intrinsic.Control.DoUntil(V.Local.bEOF,=,True)
		'loop through all of the nestids
		'read the value of Jobname and set it as NestID
		F.Global.xml.ReadNodeSetValue(V.Local.sDoc,"NestID","text",V.Local.sNestID)
		
		V.Local.iMID.Set(0)
		V.Local.iID.Set(0)
		V.Local.iDID.Set(0)
		V.Local.bEOF1.Set(false)
		
		'Get the Work Center

		'using the NESTID get the WC
		F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/WorkPlace",V.Local.sNestID,V.Local.sSQL)
		F.Global.XML.Query(V.Local.sDoc,"WC",V.Local.sSQL,True)
		'checks to see if there is a bound
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"WC",V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
			'gets the number of runs for the jobs, this number will be multiplied by the quantity and time below
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"WC","text",V.Local.sWC)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc,"WC")
			
		'using NestID create a new query to find all of the ManufacturingOrderNames
		F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder/@ManufacturingOrderName",V.Local.sNestID,V.Local.sSQL)
		F.Global.XML.Query(V.Local.sDoc,"OrderName",V.Local.sSQL,False)
		F.Intrinsic.Control.DoUntil(V.Local.bEOF1,=,True)
			
			'loop through all of the ManufacturingOrderNames and grab the fields inside of each
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"OrderName","text",V.Local.sOrderName)

			'using the ManufacturingOrderName select the information for that single order
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/NoOfRuns",V.Local.sNestID,V.Local.sOrderName,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"Runs",V.Local.sSQL,True)
			'checks to see if there is a bound
			F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"Runs",V.Local.sBound)
			F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
			F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
				'gets the number of runs for the jobs, this number will be multiplied by the quantity and time below
				F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"Runs","text",V.Local.fTotalSheets)
			F.Intrinsic.Control.EndIf
			F.Global.XML.CloseSet(V.Local.sDoc,"Runs")
			F.Intrinsic.Math.Add(V.Local.fTotalSheets,V.Local.fTotalOASheets,V.Local.fTotalOASheets)
			'select Material
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/Sheet/@SheetIdentNo",V.Local.sNestID,V.Local.sOrderName,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"Sheet",V.Local.sSQL,True)
			
			'checks to see if there is a bound
			F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"Sheet",V.Local.sBound)
			F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
			F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
				'gets the sheet name will be used for all material name later
				F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"Sheet","text",V.Local.sMaterial)
				V.Local.sMatRem.Set(V.Local.sMaterial)
			F.Intrinsic.Control.EndIf
			F.Global.XML.CloseSet(V.Local.sDoc,"Sheet")
			
			'select Material Weight
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/Sheet/SheetWeight",V.Local.sNestID,V.Local.sOrderName,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"MWeight",V.Local.sSQL,True)
			'checks to see if there is a bound
			F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"MWeight",V.Local.sBound)
			F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
			F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
				'gets the sheet name will be used for all material name later
				F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"MWeight","text",V.Local.fWeight)
			F.Intrinsic.Control.EndIf
			F.Global.XML.CloseSet(V.Local.sDoc,"MWeight")

			'select Material Length
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/Sheet[@SheetIdentNo='{2}']/Dimensions/Length",V.Local.sNestID,V.Local.sOrderName,V.Local.sMatRem,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"MLength",V.Local.sSQL,True)
			'checks to see if there is a bound
			F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"MLength",V.Local.sBound)
			F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
			F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
				'gets the sheet length
				F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"MLength","text",V.Local.fLength)
			F.Intrinsic.Control.EndIf
			F.Global.XML.CloseSet(V.Local.sDoc,"MLength")

			'select Material Width
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/Sheet[@SheetIdentNo='{2}']/Dimensions/Width",V.Local.sNestID,V.Local.sOrderName,V.Local.sMatRem,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"MWidth",V.Local.sSQL,True)
			'checks to see if there is a bound
			F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"MWidth",V.Local.sBound)
			F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
			F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
				'gets the sheet Width
				F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"MWidth","text",V.Local.fWidth)
			F.Intrinsic.Control.EndIf
			F.Global.XML.CloseSet(V.Local.sDoc,"MWidth")
			F.Intrinsic.Math.Add(V.Local.iMID,1,V.Local.iMID)
			F.Intrinsic.Math.Mult(V.Local.fLength,V.Local.fWidth,V.Local.fShtAr)
			F.Intrinsic.Math.Mult(V.Local.fTotalSheets,V.Local.fShtAr,V.Local.fRunShtAr)
			
			F.Intrinsic.Math.Add(V.Local.fTotShtAr,V.Local.fRunShtAr,V.Local.fTotShtAr)
			
			'select remaining sheets
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/RemainingSheets/RemainingSheet",V.Local.sNestID,V.Local.sOrderName,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"RemSheets",V.Local.sSQL,false)

			V.Local.bEOF3.Set(false)
			V.Local.iRemLine.Set(0)
			F.Intrinsic.Control.DoUntil(V.Local.bEOF3,=,True)
				'checks to see if there is a bound
				
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"RemSheets",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					V.Local.sRemSheets.Redim(0,0)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"RemSheets","text",V.Local.sRemSheets)
					F.Intrinsic.string.Split(V.Local.sRemSheets,V.Ambient.NewLine,V.Local.sRemSheets)
					F.Intrinsic.Control.For(V.Local.icount3,0,V.local.sRemSheets.UBound)
						F.Intrinsic.Control.if(V.Local.iCount3,<>,0)
							F.Intrinsic.math.Add(V.Local.iRemLine,1,V.Local.iRemLine)
						F.Intrinsic.Control.EndIf
						F.Intrinsic.control.If(V.Local.iRemLine,=,3)
							V.Local.sRemL.Set(V.Local.sRemSheets(V.Local.iRemLine).trim)
							V.local.fRemLength.set(V.Local.sRemL.Float)
						F.Intrinsic.Control.EndIf
						F.Intrinsic.control.If(V.Local.iRemLine,=,4)
							V.Local.sRemW.Set(V.Local.sRemSheets(V.Local.iRemLine).trim)
							V.local.fRemWidth.set(V.Local.sRemW.Float)
						F.Intrinsic.Control.EndIf
						F.Intrinsic.control.If(V.Local.iRemLine,=,8)
							V.Local.sRemWt.Set(V.Local.sRemSheets(V.Local.iRemLine).trim)
							V.local.fRemWeight.set(V.Local.sRemW.Float)
							F.Intrinsic.Math.Round(V.Local.fRemLength,2,V.Local.fRemLength)
							F.Intrinsic.Math.Round(V.Local.fRemWidth,2,V.Local.fRemWidth)
							F.Intrinsic.Math.Round(V.Local.fRemWeight,2,V.Local.fRemWeight)
							F.Intrinsic.String.Build("{0}x{1}w{2}",V.Local.fRemLength,V.Local.fRemWidth,V.Local.fRemWeight,V.Local.sSize)
							F.Intrinsic.Math.Mult(V.Local.fRemLength,V.Local.fRemWidth,V.Local.fTotalSheets,V.Local.fTotalArea)
	
							F.Intrinsic.Math.Add(V.Local.fTotalArea,V.Local.fTotDropAr,V.Local.fTotDropAr)
							F.Intrinsic.Math.Add(V.Local.iDID,1,V.Local.iDID)
							F.Intrinsic.String.Build("{0}_{1}", V.Local.sNestID, V.Local.iDID, V.Local.sDropID)
							F.Data.DataTable.AddRow("dtDrops", "NEST_ID", V.Local.sNestID, "DROP_LENGTH_INCHES", V.Local.fRemLength, "DROP_WIDTH_INCHES", V.Local.fRemWidth, "DROP_WEIGHT_POUNDS", V.Local.fRemWeight, "DROP_ID", V.Local.sDropID)
							V.Local.iRemLine.Set(0)
						F.Intrinsic.Control.EndIf
					F.Intrinsic.Control.Next(V.Local.icount3)
				F.Intrinsic.Control.EndIf
				F.Global.XML.Next(V.Local.sDoc,"RemSheets",V.Local.bEOF3)
			F.Intrinsic.Control.Loop
			F.Global.XML.CloseSet(V.Local.sDoc,"RemSheets")
			
			'reset and set drop count this breakts it out of the loop------CDDRR+DDED
			'select the jobs within this order and the part number
			V.Local.bEOF2.Set(false)
			F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part/@OrderNo",V.Local.sNestID,V.Local.sOrderName,V.Local.sSQL)
			F.Global.XML.Query(V.Local.sDoc,"Job",V.Local.sSQL,False)
			F.Intrinsic.Control.DoUntil(V.Local.bEOF2,=,True)
				'loop through all of the Jobs on this ManufacturingOrder
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"Job",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"Job","text",V.Local.sJob)
				F.Intrinsic.Control.Else
					F.Intrinsic.Control.GoTo("SkipThisOrder")
					V.Local.sJob.Set("")
				F.Intrinsic.Control.EndIf
				F.Intrinsic.String.Split(V.Local.sJob,"-",V.Local.sTJob)
				V.Local.sTJob.RedimPreserve(0,2)
				
				'using job get Time and Quantity
				F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part[@OrderNo='{2}']/TargetProcessingTimePerPiece",V.Local.sNestID,V.Local.sOrderName,V.Local.sJob,V.Local.sSQL)
				F.Global.XML.Query(V.Local.sDoc,"Time",V.Local.sSQL,True)
				V.Local.fTime.Set(0)
				'checks to see if there is a bound
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"Time",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					'get the time to process per piece time passed in minutes
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"Time","text",V.Local.fTime)
					'divide by 60 to get time in hours
					F.Intrinsic.Math.Div(V.Local.fTime,60,V.Local.fTime)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc,"Time")
				
				'get the part Weight
				F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part[@OrderNo='{2}']/PartWeight",V.Local.sNestID,V.Local.sOrderName,V.Local.sJob,V.Local.sSQL)
				F.Global.XML.Query(V.Local.sDoc,"PartWeight",V.Local.sSQL,True)
				'checks to see if there is a bound
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"PartWeight",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					'get the part length for the job
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"PartWeight","text",V.Local.fPartWeight)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc,"PartWeight")
				
				'get the part Length
				F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part[@OrderNo='{2}']/PartLength",V.Local.sNestID,V.Local.sOrderName,V.Local.sJob,V.Local.sSQL)
				F.Global.XML.Query(V.Local.sDoc,"PartLength",V.Local.sSQL,True)
				'checks to see if there is a bound
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"PartLength",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					'get the part length for the job
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"PartLength","text",V.Local.fPartLength)
					F.Intrinsic.Math.Div(V.Local.fPartLength,25.4,V.Local.fPartLength)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc,"PartLength")

				'get the part Width
				F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part[@OrderNo='{2}']/PartWidth",V.Local.sNestID,V.Local.sOrderName,V.Local.sJob,V.Local.sSQL)
				F.Global.XML.Query(V.Local.sDoc,"PartWidth",V.Local.sSQL,True)
				'checks to see if there is a bound
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"PartWidth",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					'get the part length for the job
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"PartWidth","text",V.Local.fPartWidth)
					F.Intrinsic.Math.Div(V.Local.fPartWidth,25.4,V.Local.fPartWidth)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc,"PartWidth")
			
				'get the part Area
				F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part[@OrderNo='{2}']/PartArea",V.Local.sNestID,V.Local.sOrderName,V.Local.sJob,V.Local.sSQL)
				F.Global.XML.Query(V.Local.sDoc,"PartArea",V.Local.sSQL,True)
				'checks to see if there is a bound
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"PartArea",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					'get the part area for the job
					'conver from square meters to square inches
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"PartArea","text",V.Local.fIssueAr)
					F.Intrinsic.Math.Mult(V.Local.fIssueAr,1550.0031,V.Local.fIssueAr)

				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc,"PartArea")
				
				'get the Quantity
				F.Intrinsic.String.Build("//JobFeedback[@Jobname='{0}']/ManufacturingOrders/ManufacturingOrder[@ManufacturingOrderName='{1}']/PartsOnSheet/Part[@OrderNo='{2}']/Quantity",V.Local.sNestID,V.Local.sOrderName,V.Local.sJob,V.Local.sSQL)
				F.Global.XML.Query(V.Local.sDoc,"Quantity",V.Local.sSQL,True)
				V.Local.fQty.Set(0)
				'checks to see if there is a bound
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc,"Quantity",V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound,"*!*",V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1),>,-1)
					'get the quantity
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc,"Quantity","text",V.Local.fQtyStdAln)
					F.Intrinsic.Math.mult(V.Local.fQtyStdAln,V.Local.fTotalSheets,V.Local.fQty)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc,"Quantity")
				
				F.Intrinsic.Math.mult(V.Local.fTime,V.Local.fQty,V.local.fHours)
				F.Intrinsic.Math.mult(V.local.fHours,-60,V.Local.fNegHours)
				
				Function.Intrinsic.Date.Dateadd("N",V.Local.fNegHours,V.Ambient.Now,V.Local.dStartTime)
				V.local.dEndTime.Set(V.Ambient.Now)
				
				F.Intrinsic.String.Format(V.Local.dStartTime,"HHNN",V.Local.sStartTime)
				F.Intrinsic.String.Format(V.local.dEndTime,"HHNN",V.Local.sEndTime)
				
'				F.Intrinsic.Math.Mult(V.Local.fIssueAr,V.Local.fQty,V.Local.fIssueAr)
'				F.Intrinsic.Math.Add(V.Local.fTotIssueAr,V.Local.fIssueAr,V.Local.fTotIssueAr)
				
				V.Local.sWC.Set(V.Local.sWC.UCase)
				F.Intrinsic.Math.Add(V.Local.iID,1,V.Local.iID)
				'doing this to eliminate the space for empty suffix
				F.Intrinsic.String.Build("{0}-{1}-{2}",V.Local.sTJob(0).trim,V.Local.sTJob(1).trim,V.Local.sTJob(2).trim,V.Local.sJob)
				F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.Local.sNestID, "Job", V.Local.sTJob(0).trim, "Suffix", V.Local.sTJob(1).trim, "Sequence", V.Local.sTJob(2).trim, "TOTAL_TIME_HOURS", V.Local.fHours, "GOOD_PIECES", V.Local.fQty, "PART_AREA_SQUARE_INCHES", V.Local.fIssueAr, "PART_WEIGHT_POUNDS", V.Local.fPartWeight, "WC", V.Local.sWC)
				F.Intrinsic.Control.Label("SkipThisOrder")
				F.Global.XML.Next(V.Local.sDoc,"Job",V.Local.bEOF2)
			F.Intrinsic.Control.Loop
			F.Global.XML.CloseSet(V.Local.sDoc,"Job")
				
			F.Global.XML.Next(V.Local.sDoc,"OrderName",V.Local.bEOF1)
		F.Intrinsic.Control.Loop
		F.Global.XML.CloseSet(V.Local.sDoc,"OrderName")
		F.Global.XML.Next(V.Local.sDoc,"NestID",V.Local.bEOF)
	F.Intrinsic.Control.Loop
	F.Global.XML.CloseSet(V.Local.sDoc,"NestID")
F.Intrinsic.Control.Else
	V.Global.bRead.Set(False)
	'close xml
	F.Global.XML.CloseDocument(V.Local.sDoc)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Local.sNestID, "SHEET_MATERIAL", V.Local.sMaterial.UCase, "SHEET_LOCATION", "", "SHEET_AREA_SQUARE_INCHES", V.Local.fShtAr, "SHEET_WEIGHT_POUNDS", V.Local.fWeight, "SHEET_COUNT", V.Local.fTotalOASheets.Long)

'close type
F.Global.XML.CloseSet(V.Local.sDoc,"Type")
'close xml
F.Global.XML.CloseDocument(V.Local.sDoc)

F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadBXML.End

Program.Sub.ReadBSheetXML.Start
'this is a test of converting readbsheetxml over to use the import sub
'read the boost XML doc, ProdSheetEXp, which is generated by the machine
'when a sheet is finished
'called if the Online boost option is set

F.Intrinsic.Control.Try

V.Local.sDoc.Declare(String)
V.Local.sBound.Declare(String)
V.Local.bEOF.Declare(Boolean,false)
V.Local.sWC.Declare(String)
V.Local.sJob.Declare(String)
V.Local.fShtAr.Declare(Float)
V.Local.iCount.Declare(Long)
V.Local.sJobSplit.Declare(String)
V.Local.fPartLength.Declare(Float)
V.Local.fPartWidth.Declare(Float)
V.Local.fPartWeight.Declare(Float)
V.Local.fTotalArea.Declare(Float)
V.Static.iCountDocument.Declare(Long)
V.Local.bInString.Declare(Boolean)
V.Local.sSheetID.Declare(String)
V.Local.sJobName.Declare(String)
V.Local.sManufacturingOrder.Declare(String)
V.Local.sProgramName.Declare(String)
V.Local.sQuery.Declare(String)
V.Local.sSheet.Declare(String)
V.Local.sRawMaterial.Declare(String)
V.Local.fSheetLength.Declare(Float)
V.Local.fSheetWidth.Declare(Float)
V.Local.fSheetThickness.Declare(Float)
V.Local.sUnit.Declare(String)
V.Local.fPartArea.Declare(Float)
V.Local.fGood.Declare(Float)
V.Local.fBad.Declare(Float)
V.Local.fTotal.Declare(Float)
V.Local.fSheetWeight.Declare(Float)
V.Local.sInvalidPath.Declare(String)
V.Local.fTime.Declare(Float)
V.Local.sEmployee.Declare(String)
V.Local.sTempEmployee.Declare(String)
V.Local.bEOFNest.Declare(Boolean, False)
V.Local.iNestCount.Declare(Long)
V.Global.bMove.Set(True)

'check if it's the right file type
F.Intrinsic.String.IsInString(V.Args.ImportFile, "ProdSheetExp", True, V.Local.bInString)
F.Intrinsic.Control.If(V.Local.bInString.Not)
	V.Global.bMove.Set(False)
	V.Global.bRead.Set(False)
	'move to invalid folder
	F.Intrinsic.String.Build("{0}\InvalidFile", V.Args.IMPORT_PATH, V.Local.sInvalidPath)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.ImportFile, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'create the DataTables we'll use to import
F.Intrinsic.Control.CallSub(CreateImportDataTables)

F.Intrinsic.Math.Add(V.Static.iCountDocument,1,V.Static.iCountDocument)
F.Intrinsic.String.Build("BoostSheet{0}",V.Static.iCountDocument,V.Local.sDoc)

'load in the XML
F.Global.XML.LoadDocument(V.Local.sDoc, V.Args.ImportFile, False, True, False, False)

'loop thorugh nests
F.Global.XML.Query(V.Local.sDoc, "nest", "//ProcessedSheetReports/ProcessedSheetReport", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "nest", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	'F.Global.XML.Next(V.Local.sDoc, "nest", V.Local.bEOFNest)
	V.Local.iNestCount.Set(1)
	F.Intrinsic.Control.DoUntil(V.Local.bEOFNest)
		'get Sheet ID
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/ProcessedSheetID", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sSheetID)
		F.Intrinsic.Control.Else
			V.Local.sSheetID.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get Job Name
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Jobname", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sJobName)
		F.Intrinsic.Control.Else
			V.Local.sJobName.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get Manufacturing Order
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/ManufacturingOrder", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sManufacturingOrder)
		F.Intrinsic.Control.Else
			V.Local.sManufacturingOrder.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get program name
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/ProgramName", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sProgramName)
		F.Intrinsic.Control.Else
			V.Local.sProgramName.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get WC
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/WorkPlace", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sWC)
		F.Intrinsic.Control.Else
			V.Local.sWC.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get employee
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/ReportedBy", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sTempEmployee)
			
			'employee will be GS employee ID followed by name
			F.Intrinsic.String.Split(V.Local.sTempEmployee, " ", V.Local.sTempEmployee)
			V.Local.sEmployee.Set(V.Local.sTempEmployee(0).Trim)
			V.Local.sTempEmployee.Redim(0, 0)
		F.Intrinsic.Control.Else
			V.Local.sEmployee.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get sheet info
		'get Sheet name
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/@SheetIdentNo", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sSheet)
		F.Intrinsic.Control.Else
			V.Local.sSheet.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get raw material
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/RawMaterial", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sRawMaterial)
		F.Intrinsic.Control.Else
			V.Local.sRawMaterial.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get sheet length
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/Dimensions/Length", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.fSheetLength)
		F.Intrinsic.Control.Else
			V.Local.fSheetLength.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get sheet width
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/Dimensions/Width", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.fSheetWidth)
		F.Intrinsic.Control.Else
			V.Local.fSheetWidth.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'calculate sheet area
		F.Intrinsic.Math.Mult(V.Local.fSheetLength, V.Local.fSheetWidth, V.Local.fShtAr)
		
		'get thickness
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/Dimensions/Thickness", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.fSheetThickness)
		F.Intrinsic.Control.Else
			V.Local.fSheetThickness.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get unit of measure
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/Dimensions/Unit", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.sUnit)
		F.Intrinsic.Control.Else
			V.Local.sUnit.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get sheet weight
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/Sheet/SheetWeight", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "main", "text", V.Local.fSheetWeight)
		F.Intrinsic.Control.Else
			V.Local.fSheetWeight.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "main")
		
		'get parts on sheet info
		'loop through parts
		V.Local.bEOF.Set(False)
		F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{0}]/PartsOnSheet/PartOnSheet", V.Local.iNestCount, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "main", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "main", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			V.Local.iCount.Set(1)
			F.Intrinsic.Control.DoUntil(V.Local.bEOF)
			
				'get job
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/@OrderNo", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.sJob)
				F.Intrinsic.Control.Else
					V.Local.sJob.Set("")
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get time
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/TargetProcessingTimePerPiece", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fTime)
				F.Intrinsic.Control.Else
					V.Local.fTime.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get part weight
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/PartWeight", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fPartWeight)
				F.Intrinsic.Control.Else
					V.Local.fPartWeight.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get part length
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/PartLength", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fPartLength)
				F.Intrinsic.Control.Else
					V.Local.fPartLength.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get part width
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/PartWidth", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fPartWidth)
				F.Intrinsic.Control.Else
					V.Local.fPartWidth.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get part area
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/PartArea", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fPartArea)
				F.Intrinsic.Control.Else
					V.Local.fPartArea.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get good pieces
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/ProcessedParts", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fGood)
				F.Intrinsic.Control.Else
					V.Local.fGood.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get bad pieces
				F.Intrinsic.String.Build("//ProcessedSheetReports/ProcessedSheetReport[{1}]/PartsOnSheet/PartOnSheet[{0}]/ScrapParts", V.Local.iCount, V.Local.iNestCount, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "Parts", V.Local.sQuery, False)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Parts", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Parts", "text", V.Local.fBad)
				F.Intrinsic.Control.Else
					V.Local.fBad.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "Parts")
				
				'get job, suffix, sequence
				F.Intrinsic.String.Split(V.Local.sJob, "-", V.Local.sJobSplit)
				
				'calculate total parts
				F.Intrinsic.Math.Add(V.Local.fGood, V.Local.fBad, V.Local.fTotal)
				
				'converting from Smm to SI
				F.Intrinsic.Math.Mult(V.Local.fPartArea, 1550.0031, V.Local.fPartArea)
				
				'calculate total part area
				F.Intrinsic.Math.Mult(V.Local.fTotal, V.Local.fPartArea, V.Local.fTotalArea)
				
				'calculate total time
				F.Intrinsic.Math.Mult(V.Local.fTime, V.Local.fTotal, V.Local.fTime)
				
				'convert to hours
				F.Intrinsic.Math.Div(V.Local.fTime, 60, V.Local.fTime)
				
				'add to WO datatable
				F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.Local.sManufacturingOrder, "GOOD_PIECES", V.Local.fGood, "BAD_PIECES", V.Local.fBad, "TOTAL_TIME_HOURS", V.Local.fTime, "Job", V.Local.sJobSplit(0), "Suffix", V.Local.sJobSplit(1), "Sequence", V.Local.sJobSplit(2), "PART_AREA_SQUARE_INCHES", V.Local.fPartArea, "PART_WEIGHT_POUNDS", V.Local.fPartWeight, "WC", V.Local.sWC.Trim, "EMPLOYEE", V.Local.sEmployee)
				
				F.Global.XML.Next(V.Local.sDoc, "main", V.Local.bEOF)
				F.Intrinsic.Math.Add(V.Local.iCount, 1, V.Local.iCount)
			F.Intrinsic.Control.Loop
		F.Intrinsic.Control.EndIf
		
		'add to material table
		F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Local.sManufacturingOrder, "SHEET_COUNT", 1, "SHEET_AREA_SQUARE_INCHES", V.Local.fShtAr, "SHEET_WEIGHT_POUNDS", V.Local.fSheetWeight, "SHEET_MATERIAL", V.Local.sSheet, "SHEET_LOCATION", "")
		F.Global.XML.Next(V.Local.sDoc, "nest", V.Local.bEOFNest)
		F.Intrinsic.Math.Add(V.Local.iNestCount, 1, V.Local.iNestCount)
	F.Intrinsic.Control.Loop
F.Intrinsic.Control.EndIf

F.Global.XML.CloseDocument(V.Local.sDoc)

'use the datatables we created to run the import
F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadBSheetXML.End

Program.Sub.ReadBysoftXML.Start 
'read Bysoft xml file

'file layout:
'<?xml version="1.0" encoding="Windows-1252"?>
'<JobExportData xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
'  <Guid>2edff822-2c6d-48ab-b87d-8ee96fad18a4</Guid>
'  <Name>475_2302849</Name>
'  <FileName>475-10705-01.ncp</FileName>
'  <GroupName>475-10705</GroupName>
'  <TotalParts>85</TotalParts>
'  <TotalTime>1601.745</TotalTime>
'  <TotalTimeEffective>759.058</TotalTimeEffective>
'  <CycleCounts>1</CycleCounts>
'  <CutPlansCount>1</CutPlansCount>
'  <Waste>0.62421725534153882</Waste>
'  <EffectiveWaste>0.35055664200233971</EffectiveWaste>
'  <TargetWasteValue>0</TargetWasteValue>
'  <JobState>Cut</JobState>
'  <Machine>
'    <Guid>687a98ab-c014-4681-b013-fde40e8e2539</Guid>
'    <Name>BySprint Fiber 3015 6KW</Name>
'    <Label>BySprint Fiber 3015 6KW</Label>
'    <Type>BySprint Fiber 3015</Type>
'  </Machine>
'  <Material>
'    <Guid>c3075f33-114b-4818-9aa2-7186740cdeda</Guid>
'    <Name>SHAL50120120602B</Name>
'    <Label>AL-5052</Label>
'  </Material>
'  <Sheets>
'    <Sheet>
'      <JobStateTime>2020-11-25T09:24:16</JobStateTime>
'      <StartTime>2020-11-25T09:12:29</StartTime>
'      <Measure>English</Measure>
'      <Length>120</Length>
'      <Width>60</Width>
'      <Thickness>0.12</Thickness>
'      <Density>0.098</Density>
'      <MaterialNumber>SHAL50105120602B</MaterialNumber>
'      <MachineOperator>Operator</MachineOperator>
'      <StoreName>ManualStore</StoreName>
'      <SheetCount>999852</SheetCount>
'      <JobState>Cut</JobState>
'      <CurrentCycleState>Cut</CurrentCycleState>
'      <Orders>
'        <Order>
'          <Name>A19962</Name>
'          <Label>A2311120001_001</Label>
'          <Strategy>IndividualOrder</Strategy>
'          <StartDate>2020-11-16T00:00:00</StartDate>
'          <TargetDate>2020-11-16T00:00:00</TargetDate>
'          <Info>BRACKET_SUPPORT SHIELD C AB LH</Info>
'          <Automatic>true</Automatic>
'          <CustomerName>AUTOCAR, LLC</CustomerName>
'          <CustomerNumber>AUT001</CustomerNumber>
'          <CustomerOrder>PO119435-102820</CustomerOrder>
'          <ErpInfo1>0047371</ErpInfo1>
'          <ErpInfo2>002</ErpInfo2>
'          <ErpInfo3>SHAL50120120602B </ErpInfo3>
'          <PartsCount>20</PartsCount>
'          <PartsWorking>20</PartsWorking>
'          <Parts>
'            <Part>
'              <Guid>e40d82ab-17f3-46a0-9f00-fba3f3cbdff6</Guid>
'              <Name>A2311120001_001</Name>
'              <Label>BRACKET_SUPPORT SHIELD C AB LH</Label>
'              <Measure>English</Measure>
'              <Length>8.1410661426446929</Length>
'              <Width>9.4696989860447065</Width>
'              <Area>31.831008959304938</Area>
'              <ExteriorArea>36.86846809601915</ExteriorArea>
'              <RectangularArea>77.093445796325341</RectangularArea>
'              <AreaWithEffectiveWaste>49.012756181609348</AreaWithEffectiveWaste>
'              <AreaWithWaste>84.70588235294116</AreaWithWaste>
'              <Weight>0.37433266536142606</Weight>
'              <ExteriorWeight>0.43357318480918522</ExteriorWeight>
'              <RectangularWeight>0.906618922564786</RectangularWeight>
'              <ErpDebit>20</ErpDebit>
'              <Debit>20</Debit>
'              <Count>20</Count>
'              <ProductionTime>15.283</ProductionTime>
'              <ProductionTimeEffective>7</ProductionTimeEffective>
'              <Info2>001000-002000-LAS1</Info2>
'              <Info3>BRA1~INSP~SHIP</Info3>
'              <WorkingCount>20</WorkingCount>
'            </Part>
'          </Parts>
'        </Order>
'      </Orders>
'      <ResidualSheets>
'        <ResidualSheet>
'          <Length>50.5652620760534</Length>
'          <Width>60</Width>
'          <Area>3033.9157245632041</Area>
'        </ResidualSheet>
'      </ResidualSheets>
'    </Sheet>
'  </Sheets>
'</JobExportData>

F.Intrinsic.Control.Try

V.Local.sDocument.Declare(String)
V.Local.sHeaderData.Declare(String)
V.Local.sMachineData.Declare(String)
V.Local.sMaterialData.Declare(String)
V.Local.sSheetData.Declare(String)
V.Local.sOrderData.Declare(String)
V.Local.sPartData.Declare(String)
V.Local.sResidualSheetData.Declare(String)
V.Local.iCounter.Declare(Long, 0)
V.Local.bEOF.Declare(Boolean, False)
V.Local.sQuery.Declare(String)
V.Local.sBound.Declare(String)
V.Local.fSquareInches.Declare(Float)
V.Local.fHours.Declare(Float)
V.Local.sSequence.Declare(String)
V.Local.fDropArea.Declare(Float)
V.Local.iRunCount.Declare(Long, 0)
V.Local.sSQL.Declare(String)
V.Local.sRet.Declare(String)

'use these variables for storing data
V.Local.sHeaderData.Redim(0, 12)
'0-GUID, 1-NAME, 2-Filename, 3-Groupname, 4-Total Parts, 5-TotalTime, 6-Total Time effective, 7-Cycle Counts, 8-Cut plans count, 9-Waste, 10-Effective Waste, 11-Target Waste value, 12-Job State
V.Local.sMachineData.Redim(0, 3)
'0-GUID, 1-Name, 2-Label, 3-Type
V.Local.sMaterialData.Redim(0, 4)
'0-GUID, 1-Name, 2-Label, Info1, Info2
V.Local.sSheetData.Redim(0, 12)
'0-Job State time, 1-Start time, 2-Measure, 3-Length, 4-Width, 5-Thickness, 6-Density, 7-MaterialNumber, 8-MachineOperator, 9-StoreName, 10-SheetCount, 11-JobState, 12-CurrentCycleState
V.Local.sOrderData.Redim(0, 14)
'0-Name, 1-Label, 2-Strategy, 3-StartDate, 4-TargetDate, 5-Info, 6-Automatic, 7-CustomerName, 8-CustomerNumber, 9-CustomerOrder, 10-ErpInfo1, 11-ErpInfo2, 12-ErpInfo3, 13-PartsCount, 14-PartsWorking
V.Local.sPartData.Redim(0, 21)
'0-GUID, 1-Name, 2-Label, 3-Measure, 4-Length, 5-Width, 6-Area, 7-Exterior Area, 8-Rectangular Area, 9-AreaWithEffectiveWaste, 10-AreaWithWaste, 11-Weight, 12-ExteriorWeight, 13-RectangularWeight, 14-ErpDebit, 15-Debit, 16-Count, 17-ProductionTime, 18-ProductionTimeEffective, 19-Info2, 20-Info3, 21-WorkingCount
V.Local.sResidualSheetData.Redim(0, 2)
'0-Length, 1-Width, 2-Area

'create the DataTables we'll use to import
F.Intrinsic.Control.CallSub(CreateImportDataTables)

'load in the document
F.Intrinsic.String.Build("BYSOFT-XML-{0}", V.Ambient.Now.FormatYYYYMMDDHHNNSS, V.Local.sDocument)
F.Global.XML.LoadDocument(V.Local.sDocument, V.Args.ImportFile, False, True, False, False)

'here traverse the document and grab the data we need
'first grab header data
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Guid")
V.Local.sHeaderData(0).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Name")
V.Local.sHeaderData(1).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/FileName")
V.Local.sHeaderData(2).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/GroupName")
V.Local.sHeaderData(3).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/TotalParts")
V.Local.sHeaderData(4).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/TotalTime")
V.Local.sHeaderData(5).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/TotalTimeEffective")
V.Local.sHeaderData(6).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/CycleCounts")
V.Local.sHeaderData(7).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/CutPlansCount")
V.Local.sHeaderData(8).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Waste")
V.Local.sHeaderData(9).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/EffectiveWaste")
V.Local.sHeaderData(10).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/TargetWasteValue")
V.Local.sHeaderData(11).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/JobState")
V.Local.sHeaderData(12).Set(V.Args.XML_Value)

'bysoft instead of generating a new file for each instance, bysoft updates the CutPlanCount on the same file
'hyflex doesn't want to import the whole thing at once, only how many have been cut
'so we need to see if any instances of this nest have already been imported to see the amount for this instance
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "BYSOFT_CUMULATIVE", "PROFILE", V.Args.PROFILE)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	F.Intrinsic.Control.If(V.Args.Setting)
		F.Intrinsic.String.Build("select SUM(X.RUN_COUNT) from (select distinct NEST_ID, POST_TIMESTAMP, RUN_COUNT from GCG_4980_WO_HIST where NEST_ID = '{0}') X;", V.Local.sHeaderData(1).Trim, V.Local.sSQL)
		F.ODBC.Connection!Con.ExecuteAndReturn(V.Local.sSQL, V.Local.sRet)
		F.Intrinsic.Control.If(V.Ambient.ExecuteAndReturnEOF)
			V.Local.iRunCount.Set(0)
		F.Intrinsic.Control.Else
			V.Local.iRunCount.Set(V.Local.sRet.Long)
		F.Intrinsic.Control.EndIf
		
		'if they are appending, also check nests that haven't been posted
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "APPEND", "PROFILE", V.Args.PROFILE)
		F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
			F.Intrinsic.Control.If(V.Args.Setting)
				F.Intrinsic.String.Build("select SUM(X.RUN_COUNT) from (select distinct NESTID, RUN_COUNT from GCG_4980_WO where NESTID = '{0}' and IsNull(Closed, 'N') <> 'Y' and IsNull(READY_FLAG, 'N') = 'Y') X;", V.Local.sHeaderData(1).Trim, V.Local.sSQL)
				F.ODBC.Connection!Con.ExecuteAndReturn(V.Local.sSQL, V.Local.sRet)
				F.Intrinsic.Control.If(V.Ambient.ExecuteAndReturnEOF.Not)
					F.Intrinsic.Math.Add(V.Local.iRunCount, V.Local.sRet.Long, V.Local.iRunCount)
				F.Intrinsic.Control.EndIf
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.EndIf
		
		'now calculate the new run count from these
		F.Intrinsic.Math.Sub(V.Local.sHeaderData(8).Long, V.Local.iRunCount, V.Local.iRunCount)
	F.Intrinsic.Control.Else
		V.Local.iRunCount.Set(V.Local.sHeaderData(7).Long)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Else
	V.Local.iRunCount.Set(V.Local.sHeaderData(7).Long)
F.Intrinsic.Control.EndIf

'grab machine data
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Machine/Guid")
V.Local.sMachineData(0).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Machine/Name")
V.Local.sMachineData(1).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Machine/Label")
V.Local.sMachineData(2).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Machine/Type")
V.Local.sMachineData(3).Set(V.Args.XML_Value)

'grab material data
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Material/Guid")
V.Local.sMaterialData(0).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Material/Name")
V.Local.sMaterialData(1).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Material/Label")
V.Local.sMaterialData(2).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Material/Info1")
V.Local.sMaterialData(3).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Material/Info2")
V.Local.sMaterialData(4).Set(V.Args.XML_Value)

'grab sheet data
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/JobStateTime")
V.Local.sSheetData(0).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/StartTime")
V.Local.sSheetData(1).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/Measure")
V.Local.sSheetData(2).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/Length")
V.Local.sSheetData(3).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/Width")
V.Local.sSheetData(4).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/Thickness")
V.Local.sSheetData(5).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/Density")
V.Local.sSheetData(6).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/MaterialNumber")
V.Local.sSheetData(7).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/MachineOperator")
V.Local.sSheetData(8).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/StoreName")
V.Local.sSheetData(9).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/SheetCount")
V.Local.sSheetData(10).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/JobState")
V.Local.sSheetData(11).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/CurrentCycleState")
V.Local.sSheetData(12).Set(V.Args.XML_Value)

'now read order data. There can be multiple orders so we loop
F.Global.XML.Query(V.Local.sDocument, "nest", "//JobExportData/Sheets/Sheet/Orders/Order", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDocument, "nest", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Intrinsic.Control.DoUntil(V.Local.bEOF)
		F.Intrinsic.Math.Add(V.Local.iCounter, 1, V.Local.iCounter)
		
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Name", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(0).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Label", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(1).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Strategy", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(2).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/StartDate", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(3).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/TargetDate", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(4).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Info", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(5).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Automatic", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(6).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/CustomerName", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(7).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/CustomerNumber", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(8).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/CustomerOrder", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(9).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/ErpInfo1", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(10).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/ErpInfo2", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(11).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/ErpInfo3", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(12).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/PartsCount", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(13).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/PartsWorking", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sOrderData(14).Set(V.Args.XML_Value)
		
		'grab part data
		'at the moment, not sure if there can be multiple parts per order. Assuming not
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Guid", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(0).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Name", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(1).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Label", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(2).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Measure", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(3).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Length", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(4).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Width", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(5).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Area", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(6).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/ExteriorArea", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(7).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/RectangularArea", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(8).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/AreaWithEffectiveWaste", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(9).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/AreaWithWaste", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(10).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Weight", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(11).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/ExteriorWeight", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(12).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/RectangularWeight", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(13).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/ErpDebit", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(14).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Debit", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(15).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Count", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(16).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/ProductionTime", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(17).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/ProductionTimeEffective", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(18).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Info2", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(19).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/Info3", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(20).Set(V.Args.XML_Value)
		F.Intrinsic.String.Build("//JobExportData/Sheets/Sheet/Orders/Order[{0}]/Parts/Part/WorkingCount", V.Local.iCounter, V.Local.sQuery)
		F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", V.Local.sQuery)
		V.Local.sPartData(21).Set(V.Args.XML_Value)
		
		'calculate hours
		F.Intrinsic.Math.Mult(V.Local.sPartData(17).Float, V.Local.sPartData(16).Float, V.Local.fHours)
		F.Intrinsic.Math.Div(V.Local.fHours, 3600, V.Local.fHours)
		
		'grab sequence
		F.Intrinsic.String.Split(V.Local.sOrderData(10), "-", V.Local.sSequence)
		V.Local.sSequence.RedimPreserve(0, 2)
		
		'add work order records here
		F.Intrinsic.Control.If(V.Local.sSequence(0).Trim, !=, "")
			F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.Local.sHeaderData(1).Trim, "JOB", V.Local.sSequence(0).Trim, "SUFFIX", V.Local.sSequence(1).Trim, "SEQUENCE", V.Local.sSequence(2).Trim, "TOTAL_TIME_HOURS", V.Local.fHours, "GOOD_PIECES", V.Local.sPartData(16).Float, "PART_AREA_SQUARE_INCHES", V.Local.sPartData(9).Float, "PART_WEIGHT_POUNDS", V.Local.sPartData(11).Float, "WC", V.Local.sMachineData(0).Trim, "EMPLOYEE", V.Local.sSheetData(8).Trim, "RUN_COUNT", V.Local.iRunCount)
		F.Intrinsic.Control.EndIf
		
		F.Global.XML.Next(V.Local.sDocument, "nest", V.Local.bEOF)
		
	F.Intrinsic.Control.Loop
F.Intrinsic.Control.EndIf

'now grab residual sheet data
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/ResidualSheets/ResidualSheet/Length")
V.Local.sResidualSheetData(0).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/ResidualSheets/ResidualSheet/Width")
V.Local.sResidualSheetData(1).Set(V.Args.XML_Value)
F.Intrinsic.Control.CallSub(ReadXMLValue, "Document", V.Local.sDocument, "Query", "//JobExportData/Sheets/Sheet/ResidualSheets/ResidualSheet/Area")
V.Local.sResidualSheetData(2).Set(V.Args.XML_Value)

'close the document
F.Global.XML.CloseDocument(V.Local.sDocument)

'now add the material (and drop?) records
F.Intrinsic.Math.Mult(V.Local.sSheetData(3).Float, V.Local.sSheetData(4).Float, V.Local.fSquareInches)
F.Intrinsic.Math.Sub(V.Local.fSquareInches, V.Local.sResidualSheetData(2).Float, V.Local.fSquareInches)
F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Local.sHeaderData(1).Trim, "SHEET_MATERIAL", V.Local.sMaterialData(1).Trim, "SHEET_LOCATION", "", "SHEET_AREA_SQUARE_INCHES", V.Local.fSquareInches, "SHEET_COUNT", V.Local.iRunCount)

'use the datatables we created to run the import
F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)
V.Global.bMove.Set(True)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadBysoftXML.End

Program.Sub.ReadXMLValue.Start
'pass query, document 

F.Intrinsic.Control.Try

V.Local.sBound.Declare(String)
V.Local.sValue.Declare(String, "")

F.Global.XML.Query(V.Args.Document, "main", V.Args.Query, False)
F.Global.XML.ReadNodeSetBound(V.Args.Document, "main", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Args.Document, "main", "text", V.Local.sValue)
F.Intrinsic.Control.EndIf
V.Local.sBound.Redim(0, 0)
F.Global.XML.CloseSet(V.Args.Document, "main")

F.Intrinsic.Variable.AddRV("XML_Value", V.Local.sValue)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadXMLValue.End

Program.Sub.ReadOPSXML.Start
'read OPS xml file, import

F.Intrinsic.Control.Try

V.Local.sDoc.Declare(String)
V.Local.sBound.Declare(String)
V.Local.sWC.Declare(String)
V.Local.sJob.Declare(String)
V.Local.sTJob.Declare(String)
V.Local.fTotShtAr.Declare(Float,0)
V.Local.iCount.Declare(Long)
V.Local.fTime.Declare(Float)
V.Local.fQty.Declare(Float)
V.Local.sType.Declare(String)
V.Local.sOutInvalid.Declare
V.Local.fIssueTotal.Declare(Float)
V.Local.fLength.Declare(Float)
V.Local.fWeight.Declare(Float)
V.Local.fWidth.Declare(Float)
V.Static.iCountDocument.Declare(Long)
V.Local.sFilter.Declare(String)
V.Local.sNestJobID.Declare(String)
V.Local.sSuffix.Declare(String)
V.Local.sSequence.Declare(String)
V.Local.sPartID.Declare(String)
V.Local.iParts.Declare(Long)
V.Local.iCounter.Declare(Long)
V.Local.sQuery.Declare(String)
V.Local.iPrograms.Declare(Long)
V.Local.iMaterials.Declare(Long)
V.Local.fThickness.Declare(Float)
V.Local.fPartQty.Declare(Float)
V.Local.fProgramQty.Declare(Float)
V.Local.sProgramID.Declare(String)
V.Local.sFormatCode.Declare(String)
V.Local.iJ.Declare(Long)
V.Local.sPartName.Declare(String)
V.Local.bInString.Declare(Boolean)
V.Local.bEOFParts.Declare(Boolean)
V.Local.bEOFPrograms.Declare(Boolean)
V.Local.fProduced.Declare(Float)
V.Local.fRealTime.Declare(String)
V.Local.sMachineName.Declare(String)
V.Local.fTotalWeight.Declare(Float)
V.Local.fTotalScrapWeight.Declare(Float)
V.Local.fTotalPartsWeight.Declare(Float)
V.Local.fTotalScrap.Declare(Float)
V.Local.sJobName.Declare(String)
V.Local.fQuantity.Declare(Float)
V.Local.fSum.Declare(Float)
V.Local.fWeightInJob.Declare(Float)

V.Global.bMove.Set(True)

F.Intrinsic.Control.If(V.DataTable.dtGeneral.Exists)
	F.Data.DataTable.Close("dtGeneral")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtGeneral")
F.Data.DataTable.AddColumn("dtGeneral", "Machine_Name", "String")
F.Data.DataTable.AddColumn("dtGeneral", "Job_ID", "String")
F.Data.DataTable.AddColumn("dtGeneral", "Job_Name", "String")
F.Data.DataTable.AddColumn("dtGeneral", "Quantity_Produced", "Float")
F.Data.DataTable.AddColumn("dtGeneral", "Estimated_Total_Time", "Float")
F.Data.DataTable.AddColumn("dtGeneral", "Total_Scrap", "Float")
F.Data.DataTable.AddColumn("dtGeneral", "Total_Weight", "Float")
F.Data.DataTable.AddColumn("dtGeneral", "Total_Parts_Weight", "Float")
F.Data.DataTable.AddColumn("dtGeneral", "Total_Scrap_Weight", "Float")
F.Data.DataTable.AddColumn("dtGeneral", "Materials", "Long")
F.Data.DataTable.AddColumn("dtGeneral", "Programs", "Long")
F.Data.DataTable.AddColumn("dtGeneral", "Parts", "Long")

F.Intrinsic.Control.If(V.DataTable.dtParts.Exists)
	F.Data.DataTable.Close("dtParts")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtParts")
F.Data.DataTable.AddColumn("dtParts", "Part_ID", "String")
F.Data.DataTable.AddColumn("dtParts", "Part_Name", "String")
F.Data.DataTable.AddColumn("dtParts", "Part_WC", "String")
F.Data.DataTable.AddColumn("dtParts", "Part_Length", "Float")
F.Data.DataTable.AddColumn("dtParts", "Part_Width", "Float")
F.Data.DataTable.AddColumn("dtParts", "Part_Thickness", "Float")
F.Data.DataTable.AddColumn("dtParts", "Part_Weight", "Float")
F.Data.DataTable.AddColumn("dtParts", "Part_Weight_In_Job", "Float")
F.Data.DataTable.AddColumn("dtParts", "Job", "String")
F.Data.DataTable.AddColumn("dtParts", "Suffix", "String")
F.Data.DataTable.AddColumn("dtParts", "Sequence", "String")
F.Data.DataTable.AddColumn("dtParts", "Estimated_Time", "String")
F.Data.DataTable.AddColumn("dtParts", "Real_Time", "Float")
F.Data.DataTable.AddColumn("dtParts", "Quantity_Produced", "Float")

F.Intrinsic.Control.If(V.DataTable.dtPrograms.Exists)
	F.Data.DataTable.Close("dtPrograms")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtPrograms")
F.Data.DataTable.AddColumn("dtPrograms", "Program_ID", "String")
F.Data.DataTable.AddColumn("dtPrograms", "GSS_Sheet", "String")
F.Data.DataTable.AddColumn("dtPrograms", "Sheet_Length", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Sheet_Width", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Sheet_Thickness", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Sheet_Weight", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Program_Qty", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Estimated_Time", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Real_Time", "Float")
F.Data.DataTable.AddColumn("dtPrograms", "Nest_ID", "String")

F.Intrinsic.Control.If(V.DataTable.dtPartsOnPrograms.Exists)
	F.Data.DataTable.Close("dtPartsOnPrograms")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtPartsOnPrograms")
F.Data.DataTable.AddColumn("dtPartsOnPrograms", "Program_ID", "String")
F.Data.DataTable.AddColumn("dtPartsOnPrograms", "Part_ID", "String")
F.Data.DataTable.AddColumn("dtPartsOnPrograms", "Part_Name", "String")
F.Data.DataTable.AddColumn("dtPartsOnPrograms", "Part_Qty", "Float")
F.Data.DataTable.AddColumn("dtPartsOnPrograms", "Part_Weight", "Float")
F.Data.DataTable.AddColumn("dtPartsOnPrograms", "Part_Weight_In_Program", "Float")

F.Intrinsic.Math.Add(V.Static.iCountDocument,1,V.Static.iCountDocument)
F.Intrinsic.String.Build("OPS{0}", V.Static.iCountDocument, V.Local.sDoc)
F.Global.XML.LoadDocument(V.Local.sDoc, V.Args.ImportFile ,False, True, False, False)

F.Global.XML.Query(V.Local.sDoc, "Type", "/main/general/report_type", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Type", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Type", "text", V.Local.sType)
F.Intrinsic.Control.Else
	V.Local.sType.Set("")
F.Intrinsic.Control.EndIf

'not sure if this is the best thing to check to upload, but for now
F.Intrinsic.Control.If(V.Local.sType.Trim,!=,"JOB_PRODUCED")
	V.Global.bRead.Set(False)
	'close xml
	F.Global.XML.CloseDocument(V.Local.sDoc)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf
		
'Get General Data
'nest id
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/job_id", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.sNestJobID)
F.Intrinsic.Control.Else
	V.Local.sNestJobID.Set("")
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'machine name
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/machine_name", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.sMachineName)
F.Intrinsic.Control.Else
	V.Local.sMachineName.Set("")
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'job name
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/job_name", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.sJobName)
F.Intrinsic.Control.Else
	V.Local.sJobName.Set("")
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'quantity produced
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/quantity_produced", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.fQuantity)
F.Intrinsic.Control.Else
	V.Local.fQuantity.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'total scrap
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/total_scrap", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.fTotalScrap)
F.Intrinsic.Control.Else
	V.Local.fTotalScrap.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'total weight
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/total_weight", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.fTotalWeight)
F.Intrinsic.Control.Else
	V.Local.fTotalWeight.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'total parts weight
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/total_parts_weight", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.fTotalPartsWeight)
F.Intrinsic.Control.Else
	V.Local.fTotalPartsWeight.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'total scrap weight
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/total_scrap_weight", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.fTotalScrapWeight)
F.Intrinsic.Control.Else
	V.Local.fTotalScrapWeight.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'get total time
F.Global.XML.Query(V.Local.sDoc, "general", "/main/general/estimated_total_time", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "general", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "general", "text", V.Local.fTime)
F.Intrinsic.Control.Else
	V.Local.fTime.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "general")

'get number of parts
F.Global.XML.Query(V.Local.sDoc, "parts", "/main/parts_info/number_of_parts", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "parts", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "parts", "text", V.Local.iParts)
F.Intrinsic.Control.Else
	V.Local.iParts.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "parts")

'get number of programs
F.Global.XML.Query(V.Local.sDoc, "programs", "/main/programs_info/number_of_programs", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "parts", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "programs", "text", V.Local.iPrograms)
F.Intrinsic.Control.Else
	V.Local.iPrograms.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "programs")

'get number of Materials
F.Global.XML.Query(V.Local.sDoc, "Materials", "/main/materials_info/number_of_materials", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "parts", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "Materials", "text", V.Local.iMaterials)
F.Intrinsic.Control.Else
	V.Local.iMaterials.Set(0)
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "Materials")

F.Data.DataTable.AddRow("dtGeneral", "Machine_Name", V.Local.sMachineName, "Job_ID", V.Local.sNestJobID, "Job_Name", V.Local.sJobName, "Quantity_Produced", V.Local.fQuantity, "Estimated_Total_Time", V.Local.fTime, "Total_Scrap", V.Local.fTotalScrap, "Total_Weight", V.Local.fTotalWeight, "Total_Parts_Weight", V.Local.fTotalPartsWeight, "Total_Scrap_Weight", V.Local.fTotalScrapWeight, "Materials", V.Local.iMaterials, "Programs", V.Local.iPrograms, "Parts", V.Local.iParts)

'loop through parts
V.Local.bEOFParts.Set(False)
V.Local.iCounter.Set(1)
F.Global.XML.Query(V.Local.sDoc, "Loop", "/main/parts_info/part", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Loop", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Intrinsic.Control.DoUntil(V.Local.bEOFParts)
		
		'get part ID
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/part_id", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.sPartID)
		F.Intrinsic.Control.Else
			V.Local.sPartID.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get part name / job name
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/part_name", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.sTjob)
		F.Intrinsic.Control.Else
			V.Local.sTjob.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		F.Intrinsic.String.Split(V.Local.sTjob, "-", V.Local.sTjob)
		V.Local.sJob.Set(V.Local.sTjob(0))
		V.Local.sSuffix.Set(V.Local.sTjob(1))
		V.Local.sSequence.Set(V.Local.sTjob(2))
		F.Intrinsic.String.Join(V.Local.sTjob, "-", V.Local.sTjob)
		
		'get part WC
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/work_center", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.sWC)
		F.Intrinsic.Control.Else
			V.Local.sWC.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		F.Intrinsic.String.Replace(V.Local.sWC, "L(", "", V.Local.sWC)
		F.Intrinsic.String.Replace(V.Local.sWC, ")", "", V.Local.sWC)
		
		'get length
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/dim_x", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fLength)
		F.Intrinsic.Control.Else
			V.Local.fLength.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get width
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/dim_y", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fWidth)
		F.Intrinsic.Control.Else
			V.Local.fWidth.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get weight
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/part_weight", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fWeight)
		F.Intrinsic.Control.Else
			V.Local.fWeight.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get weight in job
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/part_weight_in_job", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fWeightInJob)
		F.Intrinsic.Control.Else
			V.Local.fWeightInJob.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get thickness
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/thickness", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fThickness)
		F.Intrinsic.Control.Else
			V.Local.fThickness.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get real time
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/work_centers_info/work_center[1]/real_time", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fRealTime)
		F.Intrinsic.Control.Else
			V.Local.fRealTime.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get estimated time
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/work_centers_info/work_center[1]/estimated_time", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fTime)
		F.Intrinsic.Control.Else
			V.Local.fTime.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		'get produced
		F.Intrinsic.String.Build("/main/parts_info/part[{0}]/work_centers_info/work_center[1]/quantity_produced", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fProduced)
		F.Intrinsic.Control.Else
			V.Local.fProduced.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "part")
		
		F.Data.DataTable.AddRow("dtParts", "Part_ID", V.Local.sPartID.Trim, "Part_Name", V.Local.sTjob.Trim, "Part_WC", V.Local.sWC.Trim, "Part_Length", V.Local.fLength, "Part_Width", V.Local.fWidth, "Part_Thickness", V.Local.fThickness, "Part_Weight", V.Local.fWeight, "Job", V.Local.sJob.Trim, "Suffix", V.Local.sSuffix.Trim, "Sequence", V.Local.sSequence.Trim, "Real_Time", V.Local.fRealTime, "Quantity_Produced", V.Local.fProduced, "Estimated_Time", V.Local.fTime, "Part_Weight_In_Job", V.Local.fWeightInJob)
		
		F.Intrinsic.Math.Add(V.Local.iCounter, 1, V.Local.iCounter)
		F.Global.XML.Next(V.Local.sDoc, "Loop", V.Local.bEOFParts)
	F.Intrinsic.Control.Loop
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "Loop")

'loop through programs
V.Local.bEOFParts.Set(False)
V.Local.bEOFPrograms.Set(False)
V.Local.iCounter.Set(1)
F.Global.XML.Query(V.Local.sDoc, "Loop", "/main/programs_info/program", False)
F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Loop", V.Local.sBound)
F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
	F.Intrinsic.Control.DoUntil(V.Local.bEOFPrograms)
	
		'get program ID
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/program_id", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.sProgramID)
		F.Intrinsic.Control.Else
			V.Local.sProgramID.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get GSS Part
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/format_code", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.sFormatCode)
		F.Intrinsic.Control.Else
			V.Local.sFormatCode.Set("")
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get sheet length
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/dim_x", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fLength)
		F.Intrinsic.Control.Else
			V.Local.fLength.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get sheet width
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/dim_y", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fWidth)
		F.Intrinsic.Control.Else
			V.Local.fWidth.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get sheet thickness
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/thickness", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fThickness)
		F.Intrinsic.Control.Else
			V.Local.fThickness.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get sheet weight
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/total_weight", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fWeight)
		F.Intrinsic.Control.Else
			V.Local.fWeight.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get program qty
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/quantity_produced", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fProgramQty)
		F.Intrinsic.Control.Else
			V.Local.fProgramQty.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get estimated time
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/estimated_time", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fTime)
		F.Intrinsic.Control.Else
			V.Local.fTime.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'get real time
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/real_time", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "program", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "program", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "program", "text", V.Local.fRealTime)
		F.Intrinsic.Control.Else
			V.Local.fRealTime.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "program")
		
		'now need to loop through the parts on the programs
		'get number of parts
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/number_of_parts", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "parts", V.Local.sQuery)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "parts", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "parts", "text", V.Local.iParts)
		F.Intrinsic.Control.Else
			V.Local.iParts.Set(0)
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "parts")
		
		F.Data.DataTable.AddRow("dtPrograms", "Program_ID", V.Local.sProgramID.Trim, "GSS_Sheet", V.Local.sFormatCode.Trim, "Sheet_Length", V.Local.fLength, "Sheet_Width", V.Local.fWidth, "Sheet_Thickness", V.Local.fThickness, "Sheet_Weight", V.Local.fWeight, "Program_Qty", V.Local.fProgramQty, "Nest_ID", V.Local.sNestJobId.Trim, "Estimated_Time", V.Local.fTime, "Real_Time", V.Local.fRealTime)
		
		'loop through parts on the programs
		V.Local.bEOFParts.Set(False)
		V.Local.iJ.Set(1)
		F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/part", V.Local.iCounter, V.Local.sQuery)
		F.Global.XML.Query(V.Local.sDoc, "Loop2", V.Local.sQuery, False)
		F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "Loop2", V.Local.sBound)
		F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
		F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
			F.Intrinsic.Control.DoUntil(V.Local.bEOFParts)
				'get part ID
				F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/part[{1}]/part_id", V.Local.iCounter, V.Local.iJ, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.sPartID)
				F.Intrinsic.Control.Else
					V.Local.sPartID.Set("")
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "part")
				
				'get part name
				F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/part[{1}]/part_name", V.Local.iCounter, V.Local.iJ, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.sPartName)
				F.Intrinsic.Control.Else
					V.Local.sPartName.Set("")
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "part")
				
				'get part qty
				F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/part[{1}]/part_quantity", V.Local.iCounter, V.Local.iJ, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fPartQty)
				F.Intrinsic.Control.Else
					V.Local.fPartQty.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "part")
				
				'get part weight
				F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/part[{1}]/part_weight", V.Local.iCounter, V.Local.iJ, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fWeight)
				F.Intrinsic.Control.Else
					V.Local.fWeight.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "part")
				
				'get part weight in job
				F.Intrinsic.String.Build("/main/programs_info/program[{0}]/parts_info/part[{1}]/part_weight_in_program", V.Local.iCounter, V.Local.iJ, V.Local.sQuery)
				F.Global.XML.Query(V.Local.sDoc, "part", V.Local.sQuery)
				F.Global.XML.ReadNodeSetBound(V.Local.sDoc, "part", V.Local.sBound)
				F.Intrinsic.String.Split(V.Local.sBound, "*!*", V.Local.sBound)
				F.Intrinsic.Control.If(V.Local.sBound(1), >, -1)
					F.Global.XML.ReadNodeSetValue(V.Local.sDoc, "part", "text", V.Local.fWeightInJob)
				F.Intrinsic.Control.Else
					V.Local.fWeightInJob.Set(0)
				F.Intrinsic.Control.EndIf
				F.Global.XML.CloseSet(V.Local.sDoc, "part")
				
				F.Data.DataTable.AddRow("dtPartsOnPrograms", "Program_ID", V.Local.sProgramID.Trim, "Part_Name", V.Local.sPartName.Trim, "Part_ID", V.Local.sPartID.Trim, "Part_Qty", V.Local.fPartQty, "Part_Weight", V.Local.fWeight, "Part_Weight_In_Program", V.Local.fWeightInJob)
				
				F.Intrinsic.Math.Add(V.Local.iJ, 1, V.Local.iJ)
				F.Global.XML.Next(V.Local.sDoc, "Loop2", V.Local.bEOFParts)
			F.Intrinsic.Control.Loop
		
		F.Intrinsic.Control.EndIf
		F.Global.XML.CloseSet(V.Local.sDoc, "Loop2")
		
		F.Intrinsic.Math.Add(V.Local.iCounter, 1, V.Local.iCounter)
		F.Global.XML.Next(V.Local.sDoc, "Loop", V.Local.bEOFPrograms)
	
	F.Intrinsic.Control.Loop
F.Intrinsic.Control.EndIf
F.Global.XML.CloseSet(V.Local.sDoc, "Loop")

'close type
F.Global.XML.CloseSet(V.Local.sDoc,"Type")
'close xml
F.Global.XML.CloseDocument(V.Local.sDoc)

'so at this point
'dtparts is a list of all part info
'dtprograms is a list of sheet layouts
'dtpartsonprograms is a list of each part on each sheet layout

'calculate area for part
F.Data.DataTable.AddExpressionColumn("dtParts", "PART_AREA", "Float", "[PART_LENGTH] * [PART_WIDTH]")
F.Data.DataTable.AddExpressionColumn("dtParts", "PART_AREA_SQUARE_INCHES", "Float", "[PART_AREA] / 645.16")
F.Data.DataTable.AddExpressionColumn("dtParts", "TOTAL_PART_AREA", "Float", "[PART_AREA] * [Quantity_Produced]")
F.Data.DataTable.AddExpressionColumn("dtParts", "TOTAL_PART_WEIGHT", "Float", "[Quantity_Produced] * [PART_WEIGHT]")
F.Data.DataTable.AddExpressionColumn("dtParts", "PART_WEIGHT_POUNDS", "Float", "[PART_WEIGHT] / 453.592")

'calculations for sheet
F.Data.DataTable.AddExpressionColumn("dtPrograms", "SINGLE_SHEET_WEIGHT", "Float", "IIF([PROGRAM_QTY] = 0, 0, [SHEET_WEIGHT] / [PROGRAM_QTY])")
F.Data.DataTable.AddExpressionColumn("dtPrograms", "SINGLE_SHEET_WEIGHT_POUNDS", "Float", "[SINGLE_SHEET_WEIGHT] / 453.592")
F.Data.DataTable.AddExpressionColumn("dtPrograms", "SHEET_AREA", "Float", "[SHEET_LENGTH] * [SHEET_WIDTH]")
F.Data.DataTable.AddExpressionColumn("dtPrograms", "SHEET_AREA_SQUARE_INCHES", "Float", "[SHEET_AREA] / 645.16")
F.Data.DataTable.AddExpressionColumn("dtPrograms", "TOTAL_PROGRAM_TIME", "Float", "[ESTIMATED_TIME] * [PROGRAM_QTY]")

'need to use this to calculate time
F.Data.Linq.Join("LeftJoin", "DataTable", "dtPartsOnPrograms*!*A", "DataTable", "dtPrograms*!*B", "A.Program_ID = B.Program_ID", "DataTable", "dtParts*!*C", "A.Part_ID = C.Part_ID", "A.PROGRAM_ID*!*A.PART_ID*!*A.PART_NAME*!*B.SINGLE_SHEET_WEIGHT*!*B.SHEET_AREA*!*B.ESTIMATED_TIME*!*C.PART_AREA*!*C.PART_WEIGHT*!*A.PART_QTY*!*B.PROGRAM_QTY*!*B.TOTAL_PROGRAM_TIME", "", "", "", "dtAllPartsLayouts", True)

F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TOTAL_PART_AREA", "Float", "[PART_QTY] * [PART_AREA] * [PROGRAM_QTY]")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TOTAL_PART_WEIGHT", "Float", "[PART_WEIGHT] * [PART_QTY] * [PROGRAM_QTY]")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TOTAL_PROGRAM_SHEET_AREA", "Float", "[SHEET_AREA] * [PROGRAM_QTY]")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TOTAL_PROGRAM_SHEET_WEIGHT", "Float", "[SINGLE_SHEET_WEIGHT] * [PROGRAM_QTY]")

'here calculating based off of total sheet area
'F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TIME_PERCENTAGE_AREA", "Float", "IIF([TOTAL_PROGRAM_SHEET_AREA] = 0, 0, [TOTAL_PART_AREA] / [TOTAL_PROGRAM_SHEET_AREA])")
'F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TIME_PERCENTAGE_WEIGHT", "Float", "IIF([TOTAL_PROGRAM_SHEET_WEIGHT] = 0, 0, [TOTAL_PART_WEIGHT] / [TOTAL_PROGRAM_SHEET_WEIGHT])")

'maybe I should be calculating it as a percent of the total part area on the nest, instead of total sheet area
'here calculating based off total part area
F.Data.DataTable.AddColumn("dtAllPartsLayouts", "TOTAL_PROGRAM_PART_AREA", "Float", 0)
F.Data.DataTable.AddColumn("dtAllPartsLayouts", "TOTAL_PROGRAM_PART_WEIGHT", "Float", 0)
F.Data.DataView.Create("dtAllPartsLayouts", "dvAllPartsLayouts", 22)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtPrograms.RowCount--, 1)
	F.Intrinsic.String.Build("[PROGRAM_ID] = '{0}'", V.DataTable.dtPrograms(V.Local.iCounter).PROGRAM_ID!FieldValTrim, V.Local.sFilter)
	F.Data.DataView.SetFilter("dtAllPartsLayouts", "dvAllPartsLayouts", V.Local.sFilter)
	
	F.Data.DataTable.Compute("dtAllPartsLayouts", "Sum(TOTAL_PART_AREA)", V.Local.sFilter, V.Local.fSum)
	F.Data.DataView.SetValue("dtAllPartsLayouts", "dvAllPartsLayouts", -1, "TOTAL_PROGRAM_PART_AREA", V.Local.fSum)
	
	F.Data.DataTable.Compute("dtAllPartsLayouts", "Sum(TOTAL_PART_WEIGHT)", V.Local.sFilter, V.Local.fSum)
	F.Data.DataView.SetValue("dtAllPartsLayouts", "dvAllPartsLayouts", -1, "TOTAL_PROGRAM_PART_WEIGHT", V.Local.fSum)
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Data.DataView.Close("dtAllPartsLayouts", "dvAllPartsLayouts")

F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TIME_PERCENTAGE_AREA", "Float", "IIF([TOTAL_PROGRAM_PART_AREA] = 0, 0, [TOTAL_PART_AREA] / [TOTAL_PROGRAM_PART_AREA])")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "TIME_PERCENTAGE_WEIGHT", "Float", "IIF([TOTAL_PROGRAM_PART_WEIGHT] = 0, 0, [TOTAL_PART_WEIGHT] / [TOTAL_PROGRAM_PART_WEIGHT])")

F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "CALCULATED_TIME_AREA", "Float", "[TIME_PERCENTAGE_AREA] * [TOTAL_PROGRAM_TIME]")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "CALCULATED_TIME_WEIGHT", "Float", "[TIME_PERCENTAGE_WEIGHT] * [TOTAL_PROGRAM_TIME]")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "CALCULATED_TIME_AREA_HOURS", "Float", "[CALCULATED_TIME_AREA] / 3600")
F.Data.DataTable.AddExpressionColumn("dtAllPartsLayouts", "CALCULATED_TIME_WEIGHT_HOURS", "Float", "[CALCULATED_TIME_WEIGHT] / 3600")

'at this point we have all the data we need, add it to the import datatables
F.Intrinsic.Control.CallSub(CreateImportDataTables)

'loop through parts, get sums, add to work order dt
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtParts.RowCount--, 1)
	F.Intrinsic.String.Build("[PART_ID] = '{0}'", V.DataTable.dtParts(V.Local.iCounter).PART_ID!FieldValTrim, V.Local.sFilter)
	
	'get total time
	F.Data.DataTable.Compute("dtAllPartsLayouts", "Sum(CALCULATED_TIME_AREA_HOURS)", V.Local.sFilter, V.Local.fSum)
	
	F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.DataTable.dtGeneral(0).Job_ID!FieldValTrim, "JOB", V.DataTable.dtParts(V.Local.iCounter).JOB!FieldValTrim, "SUFFIX", V.DataTable.dtParts(V.Local.iCounter).SUFFIX!FieldValTrim, "SEQUENCE", V.DataTable.dtParts(V.Local.iCounter).SEQUENCE!FieldValTrim, "TOTAL_TIME_HOURS", V.Local.fSum, "GOOD_PIECES", V.DataTable.dtParts(V.Local.iCounter).Quantity_Produced!FieldValFloat, "BAD_PIECES", 0, "PART_AREA_SQUARE_INCHES", V.DataTable.dtParts(V.Local.iCounter).PART_AREA_SQUARE_INCHES!FieldValFloat, "PART_WEIGHT_POUNDS", V.DataTable.dtParts(V.Local.iCounter).PART_WEIGHT_POUNDS!FieldValFloat, "WC", V.DataTable.dtParts(V.Local.iCounter).PART_WC!FieldValTrim)
F.Intrinsic.Control.Next(V.Local.iCounter)

'now add sheet row, currently only support one type per nest id
F.Intrinsic.Control.If(V.DataTable.dtPrograms.RowCount, >, 0)
	F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.DataTable.dtGeneral(0).Job_ID!FieldValTrim, "SHEET_MATERIAL", V.DataTable.dtPrograms(0).GSS_SHEET!FieldValTrim, "SHEET_LOCATION", "", "SHEET_AREA_SQUARE_INCHES", V.DataTable.dtPrograms(0).SHEET_AREA_SQUARE_INCHES!FieldValFloat, "SHEET_COUNT", V.DataTable.dtGeneral(0).Quantity_Produced!FieldValFloat, "SHEET_WEIGHT_POUNDS", V.DataTable.dtPrograms(0).SINGLE_SHEET_WEIGHT_POUNDS!FieldValFloat)
F.Intrinsic.Control.EndIf

F.Data.DataTable.Close("dtPrograms")
F.Data.DataTable.Close("dtAllPartsLayouts")
F.Data.DataTable.Close("dtPartsOnPrograms")
F.Data.DataTable.Close("dtParts")
F.Data.DataTable.Close("dtGeneral")

F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadOPSXML.End

Program.Sub.ReadMetamation.Start
F.Intrinsic.Control.Try

V.Local.sHeaders.Declare(String)
V.Local.sContents.Declare(String)
V.Local.sInvalidPath.Declare(String)
V.Local.sMessage.Declare(String)
V.Local.sTypes.Declare(String)
V.Local.sDelimiter.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sWorkCenter.Declare(String)
V.Local.sMaterial.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.sJob.Declare(String)
V.Local.sTemp.Declare(String)
V.Local.sMatch.Declare(String)
V.Local.sSlash.Declare(String, "")
V.Local.sPath.Declare(String)
V.Local.sLayoutUsedColumns.Declare(String, "PARTS_AREA*!*SKELETON_AREA*!*SLUGS_AREA*!*REMNANT_HEIGHT*!*REMNANT_WIDTH*!*REMNANT_QTY*!*TOTAL*!*NAME*!*SHEET*!*SHEET_WEIGHT")
'V.Local.sPartUsedColumns.Declare(String, "TOTAL_TIME*!*WIDTH*!*HEIGHT*!*JOB_NO*!*LAYOUT_NAME*!*TOTAL*!*WEIGHT")
V.Local.sPartUsedColumns.Declare(String, "TOTAL_TIME*!*WIDTH*!*HEIGHT*!*JOB_NUMBER*!*LAYOUT_NAME*!*TOTAL*!*WEIGHT")
V.Local.bInString.Declare(Boolean)

F.Intrinsic.String.TrimCharR(V.Args.Import_Path, "\", V.Local.sPath)
F.Intrinsic.String.Build("{0}\InvalidFile", V.Local.sPath, V.Local.sInvalidPath)

'read layout file
F.Intrinsic.File.File2String(V.Args.LAYOUT_FILE, V.Local.sContents)
F.Intrinsic.String.Split(V.Local.sContents, V.Ambient.NewLine, V.Local.sContents)

F.Intrinsic.Control.If(V.Local.sContents.UBound, <, 1)
	'move to invalid folder
	F.Intrinsic.String.Build("File {0} is an ivalid file for the Metamation import. The file will be moved to {1}, as will the associated parts file {2}.", V.Args.LAYOUT_FILE, V.Local.sInvalidPath,  V.Args.PART_FILE, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
	
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.LAYOUT_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.PART_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'column order can change, so need to use headers
V.Local.sHeaders.Set(V.Local.sContents(0))
F.Intrinsic.String.Replace(V.Local.sHeaders, ",", "*!*", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, ".", "", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, " ", "_", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, "(", "", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, ")", "", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, V.Ambient.DblQuote, "", V.Local.sHeaders)

'check layout columns
F.Intrinsic.String.Split(V.Local.sLayoutUsedColumns, "*!*", V.Local.sLayoutUsedColumns)
F.Intrinsic.String.Build("*!*{0}*!*", V.Local.sHeaders, V.Local.sTemp)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sLayoutUsedColumns.UBound, 1)
	F.Intrinsic.String.Build("*!*{0}*!*", V.Local.sLayoutUsedColumns(V.Local.iCounter), V.Local.sMatch)
	F.Intrinsic.String.IsInString(V.Local.sTemp, V.Local.sMatch, True, V.Local.bInString)
	
	F.Intrinsic.Control.If(V.Local.bInString.Not)
		'move to invalid folder
		F.Intrinsic.String.Build("File {0} is an ivalid file for the Metamation import because it is missing the required field {3}. The file will be moved to {1}, as will the associated parts file {2}.", V.Args.LAYOUT_FILE, V.Local.sInvalidPath,  V.Args.PART_FILE, V.Local.sLayoutUsedColumns(V.Local.iCounter), V.Local.sMessage)
		F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
		
		F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.LAYOUT_FILE, "NEW_PATH", V.Local.sInvalidPath)
		F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.PART_FILE, "NEW_PATH", V.Local.sInvalidPath)
		F.Intrinsic.Control.ExitSub
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)
V.Local.sLayoutUsedColumns.Redim(0, 0)

F.Data.DataTable.CreateFromString("dtColumns", V.Local.sHeaders.UCase, "COLUMN", "String", "***NODELIMITER***", "*!*")
F.Data.DataTable.AddColumn("dtColumns", "TYPE", "String", "")

'build type dictionary for headers
F.Data.Dictionary.Exists("dictColumnType", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	F.Data.Dictionary.Close("dictColumnType")
F.Intrinsic.Control.EndIf

'so Metamation has a ton of columns that the user can choose to send out. Even while working with Lanzen the
'layout we were receiving changed several times. Any new columns should just be pulled in as strings. The only issue is if one of the columns we use isn't included.
'May want to add a check for that.
F.Data.Dictionary.Create("dictColumnType")
F.Data.Dictionary.AddItem("dictColumnType", "Name", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Sheet", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Operator", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Workcenter", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Setup_time", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Process_time", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Completed", "Date")
F.Data.Dictionary.AddItem("dictColumnType", "Job_reference", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Total_time", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Estimated_time", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Packing", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Parts_area", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Skeleton_area", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Slugs_area", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Material", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Total", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Last_reported", "Date")
F.Data.Dictionary.AddItem("dictColumnType", "Actual_Time_Per_Part", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Job_ID", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Layout_name", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Actual_weight", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Sheet_weight", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Parts_count", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Part_order", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Quantity", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Width", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Height", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Weight", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Job_No", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Job_Number", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Part_Weight_in_Layout", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Remnant_Height", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Remnant_Qty", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Remnant_Size", "String")
F.Data.Dictionary.AddItem("dictColumnType", "Remnant_Width", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Parts_Done", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Machine", "String")
F.Data.Dictionary.AddItem("dictColumnType", "To_Do", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Due_Date", "Date")
F.Data.Dictionary.AddItem("dictColumnType", "Parts", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Sheet_Qty", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Part_Area", "Float")
F.Data.Dictionary.AddItem("dictColumnType", "Part_Area_In_Layout", "Float")
F.Data.Dictionary.SetDefaultReturn("dictColumnType", "String")

F.Data.DataTable.FillFromDictionary("dtColumns", "dictColumnType", "COLUMN", "TYPE")

'get type list
F.Data.DataView.Create("dtColumns", "dvColumns", 22)
F.Data.DataView.ToString("dtColumns", "dvColumns", "TYPE", "***NODELIMITER***", "*!*", V.Local.sTypes)
F.Data.DataView.Close("dtColumns", "dvColumns")
F.Data.DataTable.Close("dtColumns")

'remove header row
F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sContents, 0, V.Local.sContents)
F.Intrinsic.Control.If(V.Local.sContents(V.Local.sContents.UBound).Trim, =, "")
	F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sContents, V.Local.sContents.UBound, V.Local.sContents)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Join(V.Local.sContents, "*!*", V.Local.sContents)

F.Intrinsic.String.Build("{0}*!*{0}", V.Ambient.DblQuote, V.Local.sDelimiter)
F.Intrinsic.String.Replace(V.Local.sContents, V.Local.sDelimiter, "*!*", V.Local.sContents)

F.Intrinsic.String.Build("{0},{0}", V.Ambient.DblQuote, V.Local.sDelimiter)
F.Intrinsic.String.TrimChar(V.Local.sContents, "*!*", V.Local.sContents)
F.Intrinsic.String.TrimChar(V.Local.sContents, V.Ambient.DblQuote, V.Local.sContents)
F.Data.DataTable.CreateFromString("dtLayouts", V.Local.sContents, V.Local.sHeaders, V.Local.sTypes, V.Local.sDelimiter, "*!*")

F.Intrinsic.Control.If(V.DataTable.dtLayouts.RowCount, <, 1)
	'move to invalid folder
	F.Data.Dictionary.Close("dictColumnType")
	F.Data.DataTable.Close("dtLayouts")
	F.Intrinsic.String.Build("File {0} is an ivalid file for the Metamation import. The file will be moved to {1}, as will the associated parts file {2}.", V.Args.LAYOUT_FILE, V.Local.sInvalidPath,  V.Args.PART_FILE, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
	
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.LAYOUT_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.PART_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'read part file
F.Intrinsic.File.File2String(V.Args.PART_FILE, V.Local.sContents)
F.Intrinsic.String.Split(V.Local.sContents, V.Ambient.NewLine, V.Local.sContents)

F.Intrinsic.Control.If(V.Local.sContents.UBound, <, 1)
	'move to invalid folder
	F.Data.Dictionary.Close("dictColumnType")
	F.Intrinsic.String.Build("File {0} is an ivalid file for the Metamation import. The file will be moved to {1}, as will the associated layout file {2}.", V.Args.PART_FILE, V.Local.sInvalidPath,  V.Args.LAYOUT_FILE, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
	
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.LAYOUT_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.PART_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'column order can change, so need to use headers
V.Local.sHeaders.Set(V.Local.sContents(0))
F.Intrinsic.String.Replace(V.Local.sHeaders, ",", "*!*", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, ".", "", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, " ", "_", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, "(", "", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, ")", "", V.Local.sHeaders)
F.Intrinsic.String.Replace(V.Local.sHeaders, V.Ambient.DblQuote, "", V.Local.sHeaders)

'check part columns
F.Intrinsic.String.Split(V.Local.sPartUsedColumns, "*!*", V.Local.sPartUsedColumns)
F.Intrinsic.String.Build("*!*{0}*!*", V.Local.sHeaders, V.Local.sTemp)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sPartUsedColumns.UBound, 1)
	F.Intrinsic.String.Build("*!*{0}*!*", V.Local.sPartUsedColumns(V.Local.iCounter), V.Local.sMatch)
	F.Intrinsic.String.IsInString(V.Local.sTemp, V.Local.sMatch, True, V.Local.bInString)
	
	F.Intrinsic.Control.If(V.Local.bInString.Not)
		'move to invalid folder
		F.Intrinsic.String.Build("File {0} is an ivalid file for the Metamation import because it is missing the required field {3}. The file will be moved to {1}, as will the associated parts file {2}.", V.Args.LAYOUT_FILE, V.Local.sInvalidPath,  V.Args.PART_FILE, V.Local.sPartUsedColumns(V.Local.iCounter), V.Local.sMessage)
		F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
		
		F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.LAYOUT_FILE, "NEW_PATH", V.Local.sInvalidPath)
		F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.PART_FILE, "NEW_PATH", V.Local.sInvalidPath)
		F.Intrinsic.Control.ExitSub
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)
V.Local.sPartUsedColumns.Redim(0, 0)

F.Data.DataTable.CreateFromString("dtColumns", V.Local.sHeaders.UCase, "COLUMN", "String", "***NODELIMITER***", "*!*")
F.Data.DataTable.AddColumn("dtColumns", "TYPE", "String", "")

'fill types
F.Data.DataTable.FillFromDictionary("dtColumns", "dictColumnType", "COLUMN", "TYPE")
F.Data.Dictionary.Close("dictColumnType")

'get type list
F.Data.DataView.Create("dtColumns", "dvColumns", 22)
F.Data.DataView.ToString("dtColumns", "dvColumns", "TYPE", "***NODELIMITER***", "*!*", V.Local.sTypes)
F.Data.DataView.Close("dtColumns", "dvColumns")
F.Data.DataTable.Close("dtColumns")

'remove header row
F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sContents, 0, V.Local.sContents)
F.Intrinsic.Control.If(V.Local.sContents(V.Local.sContents.UBound).Trim, =, "")
	F.Intrinsic.Variable.RemoveArrayElementByOrdinal(V.Local.sContents, V.Local.sContents.UBound, V.Local.sContents)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Join(V.Local.sContents, "*!*", V.Local.sContents)
V.Local.sContents.RedimPreserve(0, 0)

F.Intrinsic.String.Build("{0}*!*{0}", V.Ambient.DblQuote, V.Local.sDelimiter)
F.Intrinsic.String.Replace(V.Local.sContents, V.Local.sDelimiter, "*!*", V.Local.sContents)

F.Intrinsic.String.Build("{0},{0}", V.Ambient.DblQuote, V.Local.sDelimiter)
F.Intrinsic.String.TrimChar(V.Local.sContents, "*!*", V.Local.sContents)
F.Intrinsic.String.TrimChar(V.Local.sContents, V.Ambient.DblQuote, V.Local.sContents)
F.Data.DataTable.CreateFromString("dtParts", V.Local.sContents, V.Local.sHeaders, V.Local.sTypes, V.Local.sDelimiter, "*!*")

F.Intrinsic.Control.If(V.DataTable.dtParts.RowCount, <, 1)
	'move to invalid folder
	F.Data.DataTable.Close("dtParts")
	F.Intrinsic.String.Build("File {0} is an ivalid file for the Metamation import. The file will be moved to {1}, as will the associated layout file {2}.", V.Args.PART_FILE, V.Local.sInvalidPath,  V.Args.LAYOUT_FILE, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(AddLog, "Project", "4980", "Task", "Nest_Import", "Message", V.Local.sMessage)
	
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.LAYOUT_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Args.PART_FILE, "NEW_PATH", V.Local.sInvalidPath)
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.CallSub(CreateImportDataTables)

'layout file contains sheet information
'could also get this from the lxW below
F.Data.DataTable.AddExpressionColumn("dtLayouts", "SHEET_AREA", "Float", "[PARTS_AREA] + [SKELETON_AREA] + [SLUGS_AREA]")
F.Data.DataTable.AddExpressionColumn("dtLayouts", "REMNANT_AREA", "Float", "[REMNANT_HEIGHT] * [REMNANT_WIDTH]")

'take into account remnants (not tracking drops in GS, just need to account for that area)
F.Data.DataTable.AddExpressionColumn("dtLayouts", "TOTAL_REMNANT_AREA", "Float", "[REMNANT_AREA] * [REMNANT_QTY]")
F.Data.DataTable.AddExpressionColumn("dtLayouts", "TOTAL_SHEET_AREA", "Float", "[SHEET_AREA] * [TOTAL]")
F.Data.DataTable.AddExpressionColumn("dtLayouts", "TOTAL_SHEET_USAGE", "Float", "[TOTAL_SHEET_AREA] - [TOTAL_REMNANT_AREA]")
F.Data.DataTable.AddExpressionColumn("dtLayouts", "AVERAGE_SHEET_AREA", "Float", "IIF([TOTAL] = 0, 0, [TOTAL_SHEET_USAGE] / [TOTAL])")

'material is in format material, thickness: l x W
V.Local.sMaterial.Set(V.DataTable.dtLayouts(0).SHEET!FieldValTrim)
F.Intrinsic.String.Split(V.Local.sMaterial, ":", V.Local.sMaterial)
'F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.DataTable.dtLayouts(0).NAME!FieldValTrim, "SHEET_MATERIAL", V.Local.sMaterial(0), "SHEET_AREA_SQUARE_INCHES", V.DataTable.dtLayouts(0).SHEET_AREA!FieldValFloat, "SHEET_COUNT", V.DataTable.dtLayouts(0).TOTAL!FieldValFloat, "SHEET_WEIGHT_POUNDS", V.DataTable.dtLayouts(0).SHEET_WEIGHT!FieldValFloat)
F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.DataTable.dtLayouts(0).NAME!FieldValTrim, "SHEET_MATERIAL", V.Local.sMaterial(0), "SHEET_AREA_SQUARE_INCHES", V.DataTable.dtLayouts(0).AVERAGE_SHEET_AREA!FieldValFloat, "SHEET_COUNT", V.DataTable.dtLayouts(0).TOTAL!FieldValFloat, "SHEET_WEIGHT_POUNDS", V.DataTable.dtLayouts(0).SHEET_WEIGHT!FieldValFloat)
V.Local.sMaterial.Redim(0, 0)

'time is in seconds, covert to hours, add other calculated columns
F.Data.DataTable.AddExpressionColumn("dtParts", "TOTAL_TIME_HOURS", "Float", "[TOTAL_TIME] / 3600")
F.Data.DataTable.AddExpressionColumn("dtParts", "PART_AREA_SQUARE_INCHES", "Float", "[WIDTH] * [HEIGHT]")

''workcenter in the format Description(machine)(WorkCenter)
V.Local.sWorkCenter.Set(V.DataTable.dtLayouts(0).WORKCENTER!FieldValTrim)

'parts file contains part/job information
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtParts.RowCount--, 1)
	'V.Local.sJob.Set(V.DataTable.dtParts(V.Local.iCounter).JOB_NO!FieldValTrim)
	V.Local.sJob.Set(V.DataTable.dtParts(V.Local.iCounter).JOB_NUMBER!FieldValTrim)
	F.Intrinsic.String.Split(V.Local.sJob, "-", V.Local.sJob)
	
	'add to main work order dt
	F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.DataTable.dtParts(V.Local.iCounter).LAYOUT_NAME!FieldValTrim, "JOB", V.Local.sJob(0).Trim, "SUFFIX", V.Local.sJob(1).Trim, "SEQUENCE", V.Local.sJob(2).Trim, "GOOD_PIECES", V.DataTable.dtParts(V.Local.iCounter).Total!FieldValLong, "WC", V.Local.sWorkCenter, "TOTAL_TIME_HOURS", V.DataTable.dtParts(V.Local.iCounter).TOTAL_TIME_HOURS!FieldValFloat, "PART_AREA_SQUARE_INCHES", V.DataTable.dtParts(V.Local.iCounter).PART_AREA_SQUARE_INCHES!FieldValFloat, "PART_WEIGHT_POUNDS", V.DataTable.dtParts(V.Local.iCounter).WEIGHT!FieldValFloat)
	
	V.Local.sJob.Redim(0, 0)
	
F.Intrinsic.Control.Next(V.Local.iCounter)

V.Global.bMove.Set(True)
F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.LAYOUT_FILE, "SECOND_FILE", V.Args.PART_FILE, "TYPE", V.Args.ImpType)

F.Data.DataTable.Close("dtParts")
F.Data.DataTable.Close("dtLayouts")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadMetamation.End

Program.Sub.ReadMappedNestCSV.Start
'read general mapped CSV, not dependent on nesting software
'pass PROFILE, IMPORT_PATH, ImportFile, FilePrefix, RemnantFilePrefix

F.Intrinsic.Control.Try

V.Local.sContents.Declare(String)
V.Local.sSQL.Declare(String)
V.Local.sFields.Declare(String)
V.Local.sTypes.Declare(String)
V.Local.sFirstRow.Declare(String)
V.Local.bEmptyFile.Declare(Boolean)
V.Local.iCounter.Declare(Long)
V.Local.sJob.Declare(String)
V.Local.sTotalSheetAreaColumn.Declare(String)
V.Local.sTotalJobAreaColumn.Declare(String)
V.Local.sExpression.Declare(String)
V.Local.sProgramNumberColumn.Declare(String)
V.Local.sFilter.Declare(String)
V.Local.iSheets.Declare(Long)
V.Local.sPrograms.Declare(String)
V.Local.sEmptyFilePath.Declare(String)
V.Local.bInString.Declare(Boolean)
v.Local.sTempSplit.Declare(String)
V.Local.sNest.Declare(String)
V.Local.bSplitMaterial.Declare(Boolean, False)
V.Local.sDelimiter.Declare(String)
V.Local.sMaterial.Declare(String)
V.Local.bUseMetric.Declare(Boolean, False)
V.Local.sPartWeightColumn.Declare(String)
V.Local.iNestCounter.Declare(Long)
V.Local.sSheets.Declare(String)
V.Local.iRunCount.Declare(Long)
V.Local.sEmployeeIDColumn.Declare(String)
V.Local.fSum.Declare(Float)

'make sure we have the profile data
F.Intrinsic.String.Build("PROFILE = '{0}'", V.Args.Profile, V.Local.sFilter)
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile.Exists)
	F.Data.DataView.SetFilter("dtProfile", "dvProfile", V.Local.sFilter)
F.Intrinsic.Control.Else
	F.Data.Dataview.Create("dtProfile", "dvProfile", 22, V.Local.sFilter, "")
F.Intrinsic.Control.EndIf

'now load the import mapping for this profile
F.Intrinsic.String.Build("select RTRIM(IMPFIELD) IMPORT_FIELD from GCG_4980_IMPMAINT where PROFILE = '{0}' order by INDX", V.Args.Profile, V.Local.sSQL)
F.Data.DataTable.CreateFromSQL("dtImportMapping", "Con", V.Local.sSQL)
F.Data.DataTable.AddColumn("dtImportMapping", "TYPE", "String", "String")

'grab the field names and types to use when reading the CSV
F.Data.DataTable.ColumnToString("dtImportMapping", "IMPORT_FIELD", V.Local.sFields)
F.Data.DataTable.ColumnToString("dtImportMapping", "TYPE", V.Local.sTypes)
F.Data.DataTable.Close("dtImportMapping")
	
'now load the file in
F.Data.DataTable.CreateFromCSV("dtImportCSV", V.Args.ImportFile, V.Local.sFields, V.Local.sTypes, True)

'check if any data
F.Intrinsic.Control.If(V.DataTable.dtImportCSV.RowCount, >, 0)
	'check if first row contains headers
	V.Local.sFirstRow.Set(V.DataTable.dtImportCSV(0).FullRow)
	V.Local.sFirstRow.Set(V.Local.sFirstRow.Trim)
	F.Intrinsic.String.Replace(V.Local.sFirstRow, V.Ambient.NewLine, "", V.Local.sFirstRow)
	V.Local.sFields.Set(V.Local.sFields.Trim)
	F.Intrinsic.String.Replace(V.Local.sFields, V.Ambient.NewLine, "", V.Local.sFields)
	'need to fix this for Sigmanest
	F.Intrinsic.Control.If(V.Local.sFirstRow.UCase, =, V.Local.sFields.UCase, "OR", V.Args.ImpType, =, "S", V.Args.ImpType, =, "R")
		'delete first row as it contains headers
		F.Data.DataTable.DeleteRow("dtImportCSV", 0)
		F.Data.DataTable.AcceptChanges("dtImportCSV")
		
		F.Intrinsic.Control.If(V.DataTable.dtImportCSV.RowCount, =, 0)
			V.Local.bEmptyFile.Set(True)
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Control.If(V.Local.bEmptyFile.Not)
	
		'add any expression or static columns
		F.Intrinsic.Control.CallSub(AddExtraImportFields, "Profile", V.Args.Profile, "DataTable", "dtImportCSV")
		
		'now process the mapping
		'at the moment, most of the mapping is stored as columns in GCG_4980_NESTPROFILE
		'some is stored as rows in GCG_4980_SETTINGS
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "JOB_AREA", "PROFILE", V.Args.PROFILE)
		V.Local.sTotalJobAreaColumn.Set(V.Args.Setting.Trim)
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "SHEET_AREA", "PROFILE", V.Args.PROFILE)
		V.Local.sTotalSheetAreaColumn.Set(V.Args.Setting.Trim)
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "PROGRAM_NUMBER", "PROFILE", V.Args.PROFILE)
		V.Local.sProgramNumberColumn.Set(V.Args.Setting.Trim)
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "PART_WEIGHT", "PROFILE", V.Args.PROFILE)
		V.Local.sPartWeightColumn.Set(V.Args.Setting.Trim)
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_MAP", "SETTING", "EMPLOYEE_ID", "PROFILE", V.Args.PROFILE)
		V.Local.sEmployeeIDColumn.Set(V.Args.Setting.Trim)
		
		'add conversion columns
		'nest id
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).NEST_ID!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).NEST_ID!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_NEST_ID", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_NEST_ID", "String", "")
		F.Intrinsic.Control.EndIf
		
		'job
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).WO_NUMBER!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).WO_NUMBER!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_WORK_ORDER", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_WORK_ORDER", "String", "")
		F.Intrinsic.Control.EndIf
		
		'material
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).RAW_MAT!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).RAW_MAT!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_MATERIAL", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_MATERIAL", "String", "")
		F.Intrinsic.Control.EndIf
		
		'material location
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).MAT_LOCATION!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).MAT_LOCATION!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_MATERIAL_LOCATION", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_MATERIAL_LOCATION", "String", "")
		F.Intrinsic.Control.EndIf
		
		'workcenter
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).LABOR_WC!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).LABOR_WC!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_WORKCENTER", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_WORKCENTER", "String", "")
		F.Intrinsic.Control.EndIf
		
		'area per part
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).AREA_P_PART!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).AREA_P_PART!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_AREA_PER_PART", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_AREA_PER_PART", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'sheet weight
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).MAT_WEIGHT!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).MAT_WEIGHT!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_SHEET_WEIGHT", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_SHEET_WEIGHT", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'good pieces
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).GOOD_PC!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).GOOD_PC!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_GOOD_PIECES", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_GOOD_PIECES", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'Bad pieces
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).BAD_PC!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).BAD_PC!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_BAD_PIECES", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_BAD_PIECES", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'time per part
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).TIME_PER_PART!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).TIME_PER_PART!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TIME_PER_PART", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_TIME_PER_PART", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'total job area
		F.Intrinsic.Control.If(V.Local.sTotalJobAreaColumn, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.Local.sTotalJobAreaColumn, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_JOB_AREA", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_TOTAL_JOB_AREA", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'sheet area
		F.Intrinsic.Control.If(V.Local.sTotalSheetAreaColumn, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.Local.sTotalSheetAreaColumn, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_SHEET_AREA", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_SHEET_AREA", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'program number
		F.Intrinsic.Control.If(V.Local.sProgramNumberColumn, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sProgramNumberColumn, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_PROGRAM_NUMBER", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_PROGRAM_NUMBER", "String", "TRIM([PROGRAMNUMBER])")
			F.Intrinsic.Control.Else
				F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_PROGRAM_NUMBER", "String", "")
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.EndIf
		
		'part weight
		F.Intrinsic.Control.If(V.Local.sPartWeightColumn, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sPartWeightColumn, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_PART_WEIGHT", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_PART_WEIGHT", "String", "")
		F.Intrinsic.Control.EndIf
		
		'employee ID
		F.Intrinsic.Control.If(V.Local.sEmployeeIDColumn, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sEmployeeIDColumn, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_EMPLOYEE_ID", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_EMPLOYEE_ID", "String", "")
		F.Intrinsic.Control.EndIf
		
		'sheet quantity
		F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "R")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([SheetQty], '')) = '', CONVERT('0', 'System.Double'), CONVERT([SheetQty], 'System.Double'))", V.Local.sTotalSheetAreaColumn, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_SHEET_COUNT", "Float", V.Local.sExpression)
		F.Intrinsic.Control.EndIf
		
		'add calculated columns
		F.Data.DataTable.AddExpressionColumn("dtImportCSV", "FINAL_IMPORT_QUANTITY", "Float", "[IMPORT_GOOD_PIECES] + [IMPORT_BAD_PIECES]")
		F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_TIME", "Float", "[FINAL_IMPORT_QUANTITY] * [IMPORT_TIME_PER_PART]")
		
		'sigmanest comes in as hours, others usually minutes
		F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_TIME_HOURS", "Float", "[IMPORT_TOTAL_TIME]")
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_TIME_HOURS", "Float", "[IMPORT_TOTAL_TIME] / 60")
		F.Intrinsic.Control.EndIf
		
		'if using sigmanest, check the use metric option
		F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
			F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "USE_METRIC", "PROFILE", V.Args.PROFILE)
			F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
				V.Local.bUseMetric.Set(V.Args.Setting)
			F.Intrinsic.Control.EndIf
			
			F.Intrinsic.Control.If(V.Local.bUseMetric)
				'if this is on, values are coming in as Square millimeters, not square inches
				'1 Square inch = 645.16 square millimeters
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_AREA_PER_PART_FINAL", "Float", "[IMPORT_AREA_PER_PART] / 645.16")
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_JOB_AREA_FINAL", "Float", "[IMPORT_TOTAL_JOB_AREA] / 645.16")
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_SHEET_AREA_FINAL", "Float", "[IMPORT_SHEET_AREA] / 645.16")
			F.Intrinsic.Control.Else
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_AREA_PER_PART_FINAL", "Float", "[IMPORT_AREA_PER_PART]")
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_JOB_AREA_FINAL", "Float", "[IMPORT_TOTAL_JOB_AREA]")
				F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_SHEET_AREA_FINAL", "Float", "[IMPORT_SHEET_AREA]")
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_AREA_PER_PART_FINAL", "Float", "[IMPORT_AREA_PER_PART]")
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_TOTAL_JOB_AREA_FINAL", "Float", "[IMPORT_TOTAL_JOB_AREA]")
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_SHEET_AREA_FINAL", "Float", "[IMPORT_SHEET_AREA]")
		F.Intrinsic.Control.EndIf
		
		F.Data.DataTable.AddExpressionColumn("dtImportCSV", "TOTAL_USED_AREA", "Float", "IMPORT_AREA_PER_PART_FINAL * FINAL_IMPORT_QUANTITY")
		
		'create the DataTables we'll use to import
		F.Intrinsic.Control.CallSub(CreateImportDataTables)
		
		'if a sigmanest import, split the nest ID on underscore
		F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
			F.Data.DataTable.AddColumn("dtImportCSV", "IMPORT_NEST_ID_FINAL", "String", "")
			F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtImportCSV.RowCount--, 1)
				F.Intrinsic.String.Split(V.DataTable.dtImportCSV(V.Local.iCounter).IMPORT_NEST_ID!FieldValTrim, "_", V.Local.sTempSplit)
				F.Data.DataTable.SetValue("dtImportCSV", V.Local.iCounter, "IMPORT_NEST_ID_FINAL", V.Local.sTempSplit(0))
				V.Local.sTempSplit.Redim(0, 0)
			F.Intrinsic.Control.Next(V.Local.iCounter)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddExpressionColumn("dtImportCSV", "IMPORT_NEST_ID_FINAL", "String", "[IMPORT_NEST_ID]")
		F.Intrinsic.Control.EndIf
		
		'get the number of nests to loop through
		F.Data.DataTable.ColumnToString("dtImportCSV", "IMPORT_NEST_ID_FINAL", V.Local.sPrograms)
		F.Intrinsic.String.Split(V.Local.sPrograms, "*!*", V.Local.sPrograms)
		F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sPrograms, V.Local.sPrograms)
		
		F.Data.DataView.Create("dtImportCSV", "dvImportCSV", 22)
		F.Intrinsic.Control.For(V.Local.iNestCounter, 0, V.Local.sPrograms.UBound, 1)
			F.Intrinsic.String.Build("IMPORT_NEST_ID_FINAL = '{0}'", V.Local.sPrograms(V.Local.iNestCounter), V.Local.sFilter)
			F.Data.DataView.SetFilter("dtImportCSV", "dvImportCSV", V.Local.sFilter)
			
			'would be good to remove this from loop
			'if sigmanest import, check split material option
			F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
				F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "SPLIT_MATERIAL", "PROFILE", V.Args.PROFILE)
				F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
					V.Local.bSplitMaterial.Set(V.Args.Setting)
				F.Intrinsic.Control.Else
					V.Local.bSplitMaterial.Set(False)
				F.Intrinsic.Control.EndIf
				
				F.Intrinsic.Control.If(V.Local.bSplitMaterial)
					'grab the set delimiter
					F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "SPLIT_DELIMITER", "PROFILE", V.Args.PROFILE)
					F.Intrinsic.Control.If(V.Args.Setting, =, "")
						'default is -
						V.Local.sDelimiter.Set("-")
					F.Intrinsic.Control.Else
						V.Local.sDelimiter.Set(V.Args.Setting)
					F.Intrinsic.Control.EndIf
					
					'now do the split
					F.Intrinsic.String.Split(V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_MATERIAL!FieldValTrim, V.Local.sDelimiter, V.Local.sTempSplit)
					V.Local.sMaterial.Set(V.Local.sTempSplit(0).Trim)
					V.Local.sTempSplit.Redim(0, 0)
				F.Intrinsic.Control.Else
					V.Local.sMaterial.Set(V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_MATERIAL!FieldValTrim)
				F.Intrinsic.Control.EndIf
			F.Intrinsic.Control.Else
				V.Local.sMaterial.Set(V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_MATERIAL!FieldValTrim)
			F.Intrinsic.Control.EndIf
			
			'get sheet count
			F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
				F.Data.DataView.ToString("dtImportCSV", "dvImportCSV", "IMPORT_PROGRAM_NUMBER", "***NO-DELIMITER***", "*!*", V.Local.sSheets)
				F.Intrinsic.String.Split(V.Local.sSheets, "*!*", V.Local.sSheets)
				F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sSheets, V.Local.sSheets)
				F.Intrinsic.Math.Add(1, V.Local.sSheets.Ubound, V.Local.iSheets)
				V.Local.sSheets.Redim(0, 0)
				V.Local.iRunCount.Set(1)
			F.Intrinsic.Control.ElseIf(V.Args.ImpType.Trim, =, "R")
				'grab the radan sheet count field
				V.Local.iSheets.Set(V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_SHEET_COUNT!FieldValLong)
				V.Local.iRunCount.Set(V.Local.iSheets)
			F.Intrinsic.Control.Else
				V.Local.iRunCount.Set(1)
				
				'V.Local.iSheets.Set(1)
				'calculate sheets based of usage
				F.Data.DataTable.Compute("dtImportCSV", "SUM(TOTAL_USED_AREA)", V.Local.sFilter, V.Local.fSum)
				F.Intrinsic.Math.Div(V.Local.fSum, V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_SHEET_AREA_FINAL!FieldValFloat, V.Local.iSheets)
			F.Intrinsic.Control.EndIf
			
			'add row to material datatable for the material used
			F.Data.DataTable.AddRow("dtMaterial", "NEST_ID", V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_NEST_ID_FINAL!FieldValTrim, "SHEET_MATERIAL", V.Local.sMaterial, "SHEET_LOCATION", V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_MATERIAL_LOCATION!FieldValTrim, "SHEET_AREA_SQUARE_INCHES", V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_SHEET_AREA_FINAL!FieldValFloat, "SHEET_COUNT", V.Local.iSheets, "SHEET_WEIGHT_POUNDS", V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_SHEET_WEIGHT!FieldValFloat)
			
			F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Dataview.dtImportCSV!dvImportCSV.RowCount--, 1)
				F.Intrinsic.Control.If(V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_WORK_ORDER!FieldValTrim, !=, "")
					'grab job number
					F.Intrinsic.String.Split(V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_WORK_ORDER!FieldValTrim, "-", V.Local.sJob)
					V.Local.sJob.RedimPreserve(0, 2)
					
					'sometimes sequence is delimited with :
					F.Intrinsic.String.IsInString(V.Local.sJob(1), ":", True, V.Local.bInString)
					F.Intrinsic.Control.If(V.Local.bInString)
						F.Intrinsic.String.Split(V.Local.sJob(1), ":", V.Local.sTempSplit)
						V.Local.sTempSplit.RedimPreserve(0, 1)
						V.Local.sJob(1).Set(V.Local.sTempSplit(0))
						V.Local.sJob(2).Set(V.Local.sTempSplit(1))
						V.Local.sTempSplit.Redim(0, 0)
					F.Intrinsic.Control.EndIf
					
					F.Data.DataTable.AddRow("dtWorkOrders", "NEST_ID", V.Dataview.dtImportCSV!dvImportCSV(0).IMPORT_NEST_ID_FINAL!FieldValTrim, "JOB", V.Local.sJob(0).Trim, "SUFFIX", V.Local.sJob(1).Trim, "SEQUENCE", V.Local.sJob(2).Trim, "TOTAL_TIME_HOURS", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_TOTAL_TIME_HOURS!FieldValFloat, "GOOD_PIECES", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_GOOD_PIECES!FieldValFloat, "BAD_PIECES", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_BAD_PIECES!FieldValFloat, "PART_AREA_SQUARE_INCHES", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_AREA_PER_PART_FINAL!FieldValFloat, "WC", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_WORKCENTER!FieldValTrim, "WORK_ORDER_MATERIAL_USED", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_TOTAL_JOB_AREA_FINAL!FieldValFloat, "PART_WEIGHT_POUNDS", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_PART_WEIGHT!FieldValFloat, "RUN_COUNT", V.Local.iRunCount, "EMPLOYEE", V.Dataview.dtImportCSV!dvImportCSV(V.Local.iCounter).IMPORT_EMPLOYEE_ID!FieldValTrim)
					
					V.Local.sJob.Redim(0, 0)
				F.Intrinsic.Control.EndIf
				
			F.Intrinsic.Control.Next(V.Local.iCounter)
		F.Intrinsic.Control.Next(V.Local.iNestCounter)
		V.Local.sPrograms.Redim(0, 0)
		F.Data.DataView.Close("dtImportCSV", "dvImportCSV")
		F.Data.DataTable.Close("dtImportCSV")
	F.Intrinsic.Control.EndIf
	
	'now, if they have remnants set up, grab those before importing
	F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).REMNANT!FieldVal)
		F.Intrinsic.Control.CallSub(ReadMappedRemnantCSV, "Profile", V.Args.Profile, "NestFile", V.Args.ImportFile, "FilePrefix", V.Args.FilePrefix, "RemnantFilePrefix", V.Args.RemnantFilePrefix, "ImpType", V.Args.ImpType)
	F.Intrinsic.Control.EndIf
	
	'use the datatables we created to run the import
	F.Intrinsic.Control.CallSub(Import, "PROFILE", V.Args.Profile, "IMPORT_PATH", V.Args.IMPORT_PATH, "FILE", V.Args.ImportFile, "TYPE", V.Args.ImpType)
	V.Global.bMove.Set(True)
F.Intrinsic.Control.Else
	V.Local.bEmptyFile.Set(True)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.If(V.Local.bEmptyFile)
	F.Intrinsic.String.Build("{0}\EmptyFile", V.Args.Import_Path, V.Local.sEmptyFilePath)
	F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Args.ImportFile, "NEW_PATH", V.Local.sEmptyFilePath)
	V.Global.bMove.Set(False)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadMappedNestCSV.End

Program.Sub.ReadMappedRemnantCSV.Start
'read in the remnant CSV file based on the mapping and add it to the drop datatable
'pass Profile, NestFile, FilePrefix, RemnantFilePrefix

F.Intrinsic.Control.Try

V.Local.sRemnantFile.Declare(String)
V.Local.sPath.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sFields.Declare(String)
V.Local.sFirstRow.Declare(String)
V.Local.sDropIDMap.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.sTypes.Declare(String)
V.Local.sExpression.Declare(String)
V.Local.sNewFile.Declare(String)
V.Local.sNestID.Declare(String)
V.Local.sTempSplit.Declare(String)

'build file name
F.Intrinsic.File.GetFileNameFromFQN(V.Args.NestFile, V.Local.sRemnantFile)
F.Intrinsic.String.Replace(V.Local.sRemnantFile, V.Args.FilePrefix, "", V.Local.sRemnantFile)

V.Local.sPath.Set(V.DataView.dtProfile!dvProfile(0).REM_FOLDER!FieldValTrim)
F.Intrinsic.Control.If(V.Local.sPath.Right1, !=, "/", AND, V.Local.sPath.Right1, !=, "\")
	F.Intrinsic.String.Build("{0}\", V.Local.sPath, V.Local.sPath)
F.Intrinsic.Control.EndIf
F.Intrinsic.String.Build("{0}{1}{2}", V.Local.sPath, V.Args.RemnantFilePrefix, V.Local.sRemnantFile, V.Local.sRemnantFile)

'check if file exists
F.Intrinsic.File.Exists(V.Local.sRemnantFile, V.Local.bExists)

'if it does, process it, if not, exit
F.Intrinsic.Control.If(V.Local.bExists)
	'now load the remnant mapping for this profile
	V.Local.sFields.Set(V.DataView.dtProfile!dvProfile(0).REM_FMAP!FieldValTrim)
	F.Data.DataTable.CreateFromString("dtRemnantMapping", V.Local.sFields, "FIELD", "String", "***NO-DELIMITER***", ",")
	F.Data.DataTable.AddColumn("dtRemnantMapping", "TYPE", "String", "String")
	
	'grab the field names and types to use when reading the CSV
	F.Data.DataTable.ColumnToString("dtRemnantMapping", "FIELD", V.Local.sFields)
	F.Data.DataTable.ColumnToString("dtRemnantMapping", "TYPE", V.Local.sTypes)
	F.Data.DataTable.Close("dtRemnantMapping")
	
	'read the file in
	F.Data.DataTable.CreateFromCSV("dtRemnantCSV", V.Local.sRemnantFile, V.Local.sFields, V.Local.sTypes, False)
	
	F.Intrinsic.Control.If(V.DataTable.dtRemnantCSV.RowCount, >, 0)
		'check if first row contains headers
		V.Local.sFirstRow.Set(V.DataTable.dtRemnantCSV(0).FullRow)
		V.Local.sFirstRow.Set(V.Local.sFirstRow.Trim)
		F.Intrinsic.String.Replace(V.Local.sFirstRow, V.Ambient.NewLine, "", V.Local.sFirstRow)
		V.Local.sFields.Set(V.Local.sFields.Trim)
		F.Intrinsic.String.Replace(V.Local.sFields, V.Ambient.NewLine, "", V.Local.sFields)
		
		F.Intrinsic.Control.If(V.Local.sFirstRow.UCase, =, V.Local.sFields.UCase, "OR", V.Args.ImpType, =, "S")
			'delete first row as it contains headers
			F.Data.DataTable.DeleteRow("dtRemnantCSV", 0)
			F.Data.DataTable.AcceptChanges("dtRemnantCSV")
		F.Intrinsic.Control.EndIf
		
		'now process the mapping
		'at the moment, most of the mapping is stored as columns in GCG_4980_NESTPROFILE
		'some is stored as rows in GCG_4980_SETTINGS, these are retrieved with GetSetting
		F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "REMNANT_MAP", "SETTING", "DROP_ID", "PROFILE", V.Args.PROFILE)
		V.Local.sDropIDMap.Set(V.Args.Setting.Trim)
		
		'add mapping conversion fields
		'nest id
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).REM_NESTID!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.DataView.dtProfile!dvProfile(0).REM_NESTID!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtRemnantCSV", "REMNANT_NEST_ID", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtRemnantCSV", "REMNANT_NEST_ID", "String", "")
		F.Intrinsic.Control.EndIf
		
		'length (inches)
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).REM_LENGTH!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).REM_LENGTH!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtRemnantCSV", "REMNANT_LENGTH", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtRemnantCSV", "REMNANT_LENGTH", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'width (inches)
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).REM_BREADTH!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).REM_BREADTH!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtRemnantCSV", "REMNANT_WIDTH", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtRemnantCSV", "REMNANT_WIDTH", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'weight (pounds)
		F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).REM_WEIGHT!FieldValTrim, !=, "")
			F.Intrinsic.String.Build("IIF(TRIM(IsNull([{0}], '')) = '', CONVERT('0', 'System.Double'), CONVERT({0}, 'System.Double'))", V.DataView.dtProfile!dvProfile(0).REM_WEIGHT!FieldValTrim, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtRemnantCSV", "REMNANT_WEIGHT", "Float", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtRemnantCSV", "REMNANT_WEIGHT", "Float", 0)
		F.Intrinsic.Control.EndIf
		
		'drop ID
		F.Intrinsic.Control.If(V.Local.sDropIDMap, !=, "")
			F.Intrinsic.String.Build("TRIM([{0}])", V.Local.sDropIDMap, V.Local.sExpression)
			F.Data.DataTable.AddExpressionColumn("dtRemnantCSV", "REMNANT_DROP_ID", "String", V.Local.sExpression)
		F.Intrinsic.Control.Else
			F.Data.DataTable.AddColumn("dtRemnantCSV", "REMNANT_DROP_ID", "String", "")
		F.Intrinsic.Control.EndIf
	
		'add records to drop datatable
		F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtRemnantCSV.RowCount--, 1)
			F.Intrinsic.Control.If(V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_DROP_ID!FieldValTrim, !=, "")
				
				'if a sigmanest import, split the nest ID on underscore
				F.Intrinsic.Control.If(V.Args.ImpType.Trim, =, "S")
					F.Intrinsic.String.Split(V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_NEST_ID!FieldValTrim, "_", V.Local.sTempSplit)
					V.Local.sNestID.Set(V.Local.sTempSplit(0))
					V.Local.sTempSplit.Redim(0, 0)
				F.Intrinsic.Control.Else
					V.Local.sNestID.Set(V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_NEST_ID!FieldValTrim)
				F.Intrinsic.Control.EndIf
				
				F.Data.DataTable.AddRow("dtDrops", "NEST_ID", V.Local.sNestID, "DROP_ID", V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_DROP_ID!FieldValTrim, "DROP_LENGTH_INCHES", V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_LENGTH!FieldValFloat, "DROP_WIDTH_INCHES", V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_WIDTH!FieldValFloat, "DROP_WEIGHT_POUNDS", V.DataTable.dtRemnantCSV(V.Local.iCounter).REMNANT_WIDTH!FieldValFloat)
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.Next(V.Local.iCounter)
	F.Intrinsic.Control.EndIf

	F.Data.DataTable.Close("dtRemnantCSV")

	'now move the file
	F.Intrinsic.String.Build("{0}\Processed\", V.DataView.dtProfile!dvProfile(0).REM_FOLDER!FieldValTrim, V.Local.sPath)
	F.Intrinsic.File.GetFileNameFromFQN(V.Local.sRemnantFile, V.Local.sNewFile)
	F.Intrinsic.Control.CallSub(AppendFileName, "File", V.Local.sNewFile, "Append", V.Ambient.Now.FormatYYYY-MM-DD-HH-NN-SS)
	F.Intrinsic.Control.CallSub(MoveFile, "File", V.Local.sRemnantFile, "New_Path", V.Local.sPath, "New_Name", V.Args.New_Name)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.ReadMappedRemnantCSV.End

Program.Sub.CreateImportDataTables.Start
'create the standard datatables used for the import process

F.Intrinsic.Control.Try

'create DT for work orders
F.Intrinsic.Control.If(V.DataTable.dtWorkOrders.Exists)
	F.Data.DataTable.Close("dtWorkOrders")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtWorkOrders", True)
F.Data.DataTable.AddColumn("dtWorkOrders", "NEST_ID", "String", "")
F.Data.DataTable.AddColumn("dtWorkOrders", "JOB", "String", "")
F.Data.DataTable.AddColumn("dtWorkOrders", "SUFFIX", "String", "")
F.Data.DataTable.AddColumn("dtWorkOrders", "SEQUENCE", "String", "")
F.Data.DataTable.AddColumn("dtWorkOrders", "TOTAL_TIME_HOURS", "Float", 0)
F.Data.DataTable.AddColumn("dtWorkOrders", "GOOD_PIECES", "Long", 0)
F.Data.DataTable.AddColumn("dtWorkOrders", "BAD_PIECES", "Long", 0)
F.Data.DataTable.AddColumn("dtWorkOrders", "PART_AREA_SQUARE_INCHES", "Float", 0)
F.Data.DataTable.AddColumn("dtWorkOrders", "PART_WEIGHT_POUNDS", "Float", 0)
F.Data.DataTable.AddColumn("dtWorkOrders", "WC", "String", "")
F.Data.DataTable.AddColumn("dtWorkOrders", "WORK_ORDER_MATERIAL_USED", "Float", 0)
F.Data.DataTable.AddColumn("dtWorkOrders", "EMPLOYEE", "String", "")
F.Data.DataTable.AddColumn("dtWorkOrders", "RUN_COUNT", "Long", 1)

'create DT for sheets
F.Intrinsic.Control.If(V.DataTable.dtMaterial.Exists)
	F.Data.DataTable.Close("dtMaterial")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtMaterial", True)
F.Data.DataTable.AddColumn("dtMaterial", "NEST_ID", "String", "")
F.Data.DataTable.AddColumn("dtMaterial", "SHEET_MATERIAL", "String", "")
F.Data.DataTable.AddColumn("dtMaterial", "SHEET_LOCATION", "String", "")
F.Data.DataTable.AddColumn("dtMaterial", "SHEET_AREA_SQUARE_INCHES", "Float", 0)
F.Data.DataTable.AddColumn("dtMaterial", "SHEET_COUNT", "Long", 1)
F.Data.DataTable.AddColumn("dtMaterial", "SHEET_WEIGHT_POUNDS", "Float", 0)

'create DT for DROPS
F.Intrinsic.Control.If(V.DataTable.dtDrops.Exists)
	F.Data.DataTable.Close("dtDrops")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Create("dtDrops", True)
F.Data.DataTable.AddColumn("dtDrops", "NEST_ID", "String", "")
F.Data.DataTable.AddColumn("dtDrops", "DROP_ID", "String", "")
F.Data.DataTable.AddColumn("dtDrops", "DROP_LENGTH_INCHES", "Float", 0)
F.Data.DataTable.AddColumn("dtDrops", "DROP_WIDTH_INCHES", "Float", 0)
F.Data.DataTable.AddColumn("dtDrops", "DROP_WEIGHT_POUNDS", "Float", 0)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.CreateImportDataTables.End

Program.Sub.SumWorkOrders.Start
F.Intrinsic.Control.Try

'sum up records for the same sequence
'might be nice to sum up ones already in the tables as well

V.Local.fTime.Declare(Float)
V.Local.fGood.Declare(Float)
V.Local.fBad.Declare(Float)
V.Local.fMaterial.Declare(Float)
V.Local.iCounter.Declare(Long)
V.Local.sFilter.Declare(String)

'something is messed up here

F.Data.DataView.Create("dtWorkOrders", "dvDistinct", 22)
F.Data.DataView.ToDataTableDistinct("dtWorkOrders", "dvDistinct", "dtDistinctWorkOrders", "NEST_ID*!*JOB*!*SUFFIX*!*SEQUENCE*!*EMPLOYEE")
F.Data.DataTable.Clone("dtWorkOrders", "dtWorkOrdersDistinct", True)

F.Data.DataTable.AddExpressionColumn("dtWorkOrders", "WORK_ORDER_SUM_GOOD_PIECES", "Float", "[GOOD_PIECES] * [RUN_COUNT]")
F.Data.DataTable.AddExpressionColumn("dtWorkOrders", "WORK_ORDER_SUM_BAD_PIECES", "Float", "[BAD_PIECES] * [RUN_COUNT]")
F.Data.DataTable.AddExpressionColumn("dtWorkOrders", "WORK_ORDER_SUM_TOTAL_TIME_HOURS", "Float", "[TOTAL_TIME_HOURS] * [RUN_COUNT]")
F.Data.DataTable.AddExpressionColumn("dtWorkOrders", "WORK_ORDER_SUM_WORK_ORDER_MATERIAL_USED", "Float", "[WORK_ORDER_MATERIAL_USED] * [RUN_COUNT]")

F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtDistinctWorkOrders.RowCount--, 1)
	F.Intrinsic.String.Build("NEST_ID = '{0}' and JOB = '{1}' and SUFFIX = '{2}' and SEQUENCE = '{3}' and EMPLOYEE = '{4}'", V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).NEST_ID!FieldValTrim, V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).JOB!FieldValTrim, V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).SUFFIX!FieldValTrim, V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).SEQUENCE!FieldValTrim, V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).EMPLOYEE!FieldValTrim, V.Local.sFilter)
	
	F.Data.DataView.SetFilter("dtWorkOrders", "dvDistinct", V.Local.sFilter)
	F.Intrinsic.Control.If(V.DataView.dtWorkOrders!dvDistinct.RowCount, >, 0)
		F.Data.DataTable.Compute("dtWorkOrders", "Sum(WORK_ORDER_SUM_TOTAL_TIME_HOURS)", V.Local.sFilter, V.Local.fTime)
		F.Data.DataTable.Compute("dtWorkOrders", "Sum(WORK_ORDER_SUM_GOOD_PIECES)", V.Local.sFilter, V.Local.fGood)
		F.Data.DataTable.Compute("dtWorkOrders", "Sum(WORK_ORDER_SUM_BAD_PIECES)", V.Local.sFilter, V.Local.fBad)
		F.Data.DataTable.Compute("dtWorkOrders", "Sum(WORK_ORDER_SUM_WORK_ORDER_MATERIAL_USED)", V.Local.sFilter, V.Local.fMaterial)
		
		F.Data.DataTable.AddRow("dtWorkOrdersDistinct", "NEST_ID", V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).NEST_ID!FieldValTrim, "JOB", V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).JOB!FieldValTrim, "SUFFIX", V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).SUFFIX!FieldValTrim, "SEQUENCE", V.DataTable.dtDistinctWorkOrders(V.Local.iCounter).SEQUENCE!FieldValTrim, "TOTAL_TIME_HOURS", V.Local.fTime, "GOOD_PIECES", V.Local.fGood, "BAD_PIECES", V.Local.fBad, "PART_AREA_SQUARE_INCHES", V.DataView.dtWorkOrders!dvDistinct(0).PART_AREA_SQUARE_INCHES!FieldValFloat, "PART_WEIGHT_POUNDS", V.DataView.dtWorkOrders!dvDistinct(0).PART_WEIGHT_POUNDS!FieldValFloat, "WC", V.DataView.dtWorkOrders!dvDistinct(0).WC!FieldValTrim, "WORK_ORDER_MATERIAL_USED", V.Local.fMaterial, "EMPLOYEE", V.DataView.dtWorkOrders!dvDistinct(0).EMPLOYEE!FieldValTrim, "RUN_COUNT", 1)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Data.DataView.Close("dtWorkOrders", "dvDistinct")
F.Data.DataTable.Close("dtDistinctWorkOrders")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.SumWorkOrders.End

Program.Sub.Import.Start
'take the info provided in the dtWorkOrders and dtMaterial datatables
'gather extra data, import them

F.Intrinsic.Control.Try

V.Local.sOutInvalid.Declare(String)
V.Local.sSQL.Declare(String)
V.Local.sSheetPartNumbers.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sImportPath.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.bImportDrops.Declare(Boolean, False)
V.Local.sJobs.Declare(String)
V.Local.sProfile.Declare(String)
V.Local.sImportFile.Declare(String)
V.Local.sNewPath.Declare(String)
V.Local.bAppend.Declare(Boolean, False)
V.Local.sFilter.Declare(String)
V.Local.sSecondFile.Declare(String, "")
V.Local.sContents.Declare(String)
V.Local.sExtension.Declare(String)
V.Local.sHeaders.Declare(String)
V.Local.bIssueMaterial.Declare(Boolean, False)
V.Local.bInches.Declare(Boolean, False)
V.Local.bUseSerialForSize.Declare(Boolean, False)
V.Local.sExpression.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.sNests.Declare(String)
V.Local.fSum.Declare(Float)
V.Local.sRet.Declare(String)
V.Local.bAllowZeroMaterial.Declare(Boolean)

V.Local.sProfile.Set(V.Args.Profile)
V.Local.sImportFile.Set(V.Args.File)

F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "APPEND", "PROFILE", V.Args.PROFILE)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	V.Local.bAppend.Set(V.Args.Setting.Trim)
F.Intrinsic.Control.EndIf

F.Intrinsic.Variable.ArgExists("SECOND_FILE", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	V.Local.sSecondFile.Set(V.Args.SECOND_FILE.Trim)
F.Intrinsic.Control.EndIf

'get import path
F.Intrinsic.Variable.ArgExists("IMPORT_PATH", V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists)
	V.Local.sImportPath.Set(V.Args.IMPORT_PATH.Trim)
	F.Intrinsic.String.TrimCharR(V.Local.sImportPath, "\", V.Local.sImportPath)
F.Intrinsic.Control.Else
	F.Intrinsic.String.Build("{0}\Custom\4980\{1}\{2}\Import", V.Caller.GlobalDir, V.Caller.CompanyCode, V.Local.sProfile.Trim, V.Local.sImportPath)
F.Intrinsic.Control.EndIf

'check work order dt
F.Intrinsic.Control.If(V.DataTable.dtWorkOrders.Exists)
	F.Intrinsic.Control.If(V.DataTable.dtWorkOrders.RowCount, =, 0)
		'No records to import, exit
		F.Intrinsic.Control.ExitSub
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Else
	'no DT to import from, exit
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'check sheet dt
F.Intrinsic.Control.If(V.DataTable.dtMaterial.Exists)
	F.Intrinsic.Control.If(V.DataTable.dtMaterial.RowCount, =, 0)
		'No records to import, exit
		F.Intrinsic.Control.ExitSub
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Else
	'no DT to import from, exit
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("PROFILE = '{0}'", V.Local.sProfile, V.Local.sFilter)
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile.Exists)
	F.Data.DataView.SetFilter("dtProfile", "dvProfile", V.Local.sFilter)
F.Intrinsic.Control.Else
	F.Data.Dataview.Create("dtProfile", "dvProfile", 22, V.Local.sFilter, "")
F.Intrinsic.Control.EndIf

'grab material issue setting
V.Local.bIssueMaterial.Set(V.DataView.dtProfile!dvProfile(0).BACK_FLUSH_MAT!FieldVal)

'check drops
F.Intrinsic.Control.If(V.Local.bIssueMaterial)
	F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).REMNANT!FieldVal)
		F.Intrinsic.Control.If(V.DataTable.dtDrops.Exists)
			F.Intrinsic.Control.If(V.DataTable.dtDrops.RowCount, >, 0)
				V.Local.bImportDrops.Set(True)
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

'group nest
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "GROUP_NESTS_BY_FILE", "PROFILE", V.Args.PROFILE)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	F.Intrinsic.Control.If(V.Args.Setting)
		F.Intrinsic.Control.CallSub(GroupNest, "File", V.Local.sImportFile)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

'sum up records for the same sequence
F.Intrinsic.Control.CallSub(SumWorkOrders)
F.Data.DataTable.Close("dtWorkOrders")

F.Intrinsic.Control.If(V.Local.sSecondFile.Trim, !=, "")
	F.Intrinsic.String.Build("{0}:{1}", V.Local.sImportFile, V.Local.sSecondFile, V.Local.sFile)
F.Intrinsic.Control.Else
	V.Local.sFile.Set(V.Local.sImportFile)
F.Intrinsic.Control.EndIf
F.Data.DataTable.AddColumn("dtWorkOrdersDistinct", "FILE", "String", V.Local.sFile)
F.Data.Linq.Join("LeftJoin", "DataTable", "dtWorkOrdersDistinct*!*A", "DataTable", "dtMaterial*!*B", "A.NEST_ID = B.NEST_ID", "*", "", "", "", "dtFullNest", True)
F.Data.DataTable.Close("dtWorkOrdersDistinct")
F.Data.DataTable.Close("dtMaterial")

'check options for sheet weight and sheet area
F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "USE_PART_WEIGHT_SUM", "PROFILE", V.Args.PROFILE)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	F.Intrinsic.Control.If(V.Args.Setting)
		F.Data.DataTable.AddExpressionColumn("dtFullNest", "USE_PART_WEIGHT_SUM_CALCULATION", "Float", "[PART_WEIGHT_POUNDS] * ([GOOD_PIECES] + [BAD_PIECES]) / [SHEET_COUNT]")
		F.Intrinsic.Control.CallSub(SumFieldByKey, "DataTable", "dtFullNest", "Key", "NEST_ID", "Source", "USE_PART_WEIGHT_SUM_CALCULATION", "Target", "SHEET_WEIGHT_POUNDS")
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "USE_PART_AREA_SUM", "PROFILE", V.Args.PROFILE)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	F.Intrinsic.Control.If(V.Args.Setting)
		F.Data.DataTable.AddExpressionColumn("dtFullNest", "USE_PART_AREA_SUM_CALCULATION", "Float", "[PART_AREA_SQUARE_INCHES] * ([GOOD_PIECES] + [BAD_PIECES])  / [SHEET_COUNT]")
		F.Intrinsic.Control.CallSub(SumFieldByKey, "DataTable", "dtFullNest", "Key", "NEST_ID", "Source", "USE_PART_AREA_SUM_CALCULATION", "Target", "SHEET_AREA_SQUARE_INCHES")
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

'WC Cross Reference
F.Intrinsic.Control.If(V.DataView.dtProfile!dvProfile(0).WC_XREF!FieldVal)
	F.Intrinsic.String.Build("Select RTRIM(XREF) as XREF, WC from GCG_4980_WCXREF where profile = '{0}'", V.Local.sProfile, V.Local.sSQL)
	F.Data.Dictionary.CreateFromSQL("dictWCXref", "Con", V.Local.sSQL)
	F.Data.Dictionary.SetDefaultReturn("dictWCXref", "")
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWCXref", "WC")
	F.Data.Dictionary.Close("dictWCXref")
F.Intrinsic.Control.EndIf

'trim WC just in case
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FINAL_WC", "String", "Trim(SUBSTRING([WC] + '    ', 1, 4))")

'full job
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FULL_JOB", "String", "TRIM([JOB]) + '-' + TRIM([SUFFIX]) + '-' + TRIM([SEQUENCE])")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "JOB_SUFFIX", "String", "TRIM([JOB]) + '-' + TRIM([SUFFIX])")

'get work order part
F.Data.DataTable.AddColumn("dtFullNest", "WORK_ORDER_PART", "String")
F.Data.DataTable.AddColumn("dtFullNest", "WORK_ORDER_PART_LOCATION", "String")

F.Data.DataView.Create("dtFullNest", "dvWorkOrderString", 22)
F.Data.DataView.ToString("dtFullNest", "dvWorkOrderString", "JOB_SUFFIX", "$^@#%", "','", V.Local.sJobs)
F.Data.DataView.Close("dtFullNest", "dvWorkOrderString")

F.Intrinsic.String.Build("select RTRIM(JOB) + '-' + RTRIM(SUFFIX) as JS, RTRIM(PART) as PART, RTRIM(LOCATION) as LOCATION from V_JOB_HEADER where JS in ('{0}')", V.Local.sJobs, V.Local.sSQL)
F.Data.DataTable.CreateFromSQL("dtJobParts", "Con", V.Local.sSQL)

F.Data.Dictionary.CreateFromDataTable("dictWOPart", "dtJobParts", "JS", "PART")
F.Data.Dictionary.SetDefaultReturn("dictWOPart", "")
F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWOPart", "JOB_SUFFIX", "WORK_ORDER_PART")
F.Data.Dictionary.Close("dictWOPart")

F.Data.Dictionary.CreateFromDataTable("dictWOPartLoc", "dtJobParts", "JS", "Location")
F.Data.Dictionary.SetDefaultReturn("dictWOPartLoc", "")
F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWOPartLoc", "JOB_SUFFIX", "WORK_ORDER_PART_LOCATION")
F.Data.Dictionary.Close("dictWOPartLoc")

F.Data.DataTable.Close("dtJobParts")

'Final locations
'***********************************************************************************
F.Data.DataTable.AddExpressionColumn("dtFullNest", "MATERIAL_AND_LOCATION", "String", "TRIM(ISNULL([SHEET_MATERIAL], ' ')) + Trim(ISNULL([SHEET_LOCATION], ' '))")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "PART_AND_LOCATION", "String", "TRIM(ISNULL([WORK_ORDER_PART], ' ')) + TRIM(ISNULL([WORK_ORDER_PART_LOCATION], ' '))")
'Changed 7/24/2019 by Alejandro Anazco

'check for valid work orders
F.Data.Dictionary.CreateFromSQL("dictJSS","Con","SELECT rtrim(ltrim(JOB)) + '-' + rtrim(ltrim(SUFFIX)) + '-' + rtrim(ltrim(SEQ)) AS JOBSUFFIXSEQ, 'Y' AS VALID FROM V_JOB_OPERATIONS WHERE LMO = 'L' AND (SEQ < '995000' Or SEQ = '998000')")
F.Data.Dictionary.SetDefaultReturn("dictJSS","N")
F.Data.DataTable.AddColumn("dtFullNest","VALID","String")
F.Data.DataTable.FillFromDictionary("dtFullNest","dictJSS","FULL_JOB","VALID")
F.Data.Dictionary.Close("dictJSS")

F.Data.DataView.Create("dtFullNest","dvCheck",22,"VALID = 'N'","")
F.Intrinsic.Control.If(V.DataView.dtFullNest!dvCheck.RowCount, =, V.DataTable.dtFullNest.RowCount)
	'output invalid WO file
	F.Intrinsic.String.Build("{0}\InvalidWO", V.Local.sImportPath, V.Local.sNewPath)
	F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sImportFile, "NEW_PATH", V.Local.sNewPath)
	F.Intrinsic.Control.If(V.Local.sSecondFile, !=, "")
		F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sSecondFile, "NEW_PATH", V.Local.sNewPath)
	F.Intrinsic.Control.EndIf
	V.Global.bMove.Set(False)
	F.Data.DataView.Close("dtFullNest", "dvCheck")
	F.Data.Dataview.Close("dtProfile", "dvProfile")
	F.Data.DataTable.Close("dtFullNest")
	F.Intrinsic.Control.ExitSub

F.Intrinsic.Control.ElseIf(V.DataView.dtFullNest!dvCheck.RowCount, >, 0)
	'output bad records
	F.Data.DataView.ToString("dtFullNest", "dvCheck", V.DataTable.dtFullNest.FieldNames, ",", V.Ambient.NewLine, V.Local.sContents)
	F.Intrinsic.String.Replace(V.DataTable.dtFullNest.FieldNames, "*!*", ",", V.Local.sHeaders)
	F.Intrinsic.String.Build("{0}{1}{2}", V.Local.sHeaders, V.Ambient.NewLine, V.Local.sContents, V.Local.sContents)
	F.Intrinsic.File.GetFileNameFromFQN(V.Local.sImportFile, V.Local.sNewPath)
	F.Intrinsic.File.GetExtensionComponent(V.Local.sNewPath, V.Local.sExtension)
	F.Intrinsic.String.Build(".{0}", V.Local.sExtension, V.Local.sExtension)
	F.Intrinsic.String.Replace(V.Local.sNewPath, V.Local.sExtension, "", V.Local.sNewPath)
	F.Intrinsic.String.Build("{0}\InvalidWO\{1}_INVALID_WORK_ORDERS_{2}.csv", V.Local.sImportPath, V.Local.sNewPath, V.Ambient.Now.FormatYYYY-MM-DD-HH-NN-SS, V.Local.sNewPath)
	F.Intrinsic.File.String2File(V.Local.sNewPath, V.Local.sContents)
F.Intrinsic.Control.EndIf

F.Data.DataTable.AddColumn("dtFullNest", "SHEET_UM", "String", "")
F.Data.DataTable.AddColumn("dtFullNest", "GS_SHEET_LENGTH", Float, 0)
F.Data.DataTable.AddColumn("dtFullNest", "GS_PART_LENGTH", Float, 0)
F.Data.DataTable.AddColumn("dtFullNest", "GS_SHEET_WIDTH", Float, 0)
F.Data.DataTable.AddColumn("dtFullNest", "GS_PART_WIDTH", Float, 0)
F.Data.DataTable.AddColumn("dtFullNest", "GS_SHEET_WEIGHT", Float, 0)
F.Data.DataTable.AddColumn("dtFullNest", "GS_PART_WEIGHT", Float, 0)

F.Intrinsic.Control.If(V.Local.bIssueMaterial)
	'grab GSS materials/long part
	F.Data.Dictionary.CreateFromSQL("dictTemp", "Con", "Select RTRIM(PART), RTRIM(PART) from V_INVENTORY_MSTR union select RTRIM(DISPLAY_PART), RTRIM(GSS_PART) from INV_LXR")
	F.Data.Dictionary.SetDefaultReturn("dictTemp", "")
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictTemp", "SHEET_MATERIAL", "SHEET_MATERIAL")
	F.Data.Dictionary.Close("dictTemp")
	
	'get sheet UM
	F.Data.Dictionary.CreateFromSQL("dictUM","Con","Select RTRIM(PART) + RTRIM(LOCATION) as PartLoc, RTRIM(UM_INVENTORY) from V_INVENTORY_MSTR where PART <> ''")
	F.Data.Dictionary.SetDefaultReturn("dictUM","")
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictUM", "MATERIAL_AND_LOCATION", "SHEET_UM")
	F.Data.Dictionary.Close("dictUM")
	
	'check if material is valid
	F.Intrinsic.Control.If(V.Local.bIssueMaterial)
		F.Data.DataView.SetFilter("dtFullNest", "dvCheck", "IsNull([SHEET_UM], '') <> ''")
		F.Intrinsic.Control.If(V.DataView.dtFullNest!dvCheck.RowCount, =, 0)
			F.Intrinsic.String.Build("{0}\InvalidMaterial", V.Local.sImportPath, V.Local.sNewPath)
			F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sImportFile, "NEW_PATH", V.Local.sNewPath)
			F.Intrinsic.Control.If(V.Local.sSecondFile, !=, "")
				F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sSecondFile, "NEW_PATH", V.Local.sNewPath)
			F.Intrinsic.Control.EndIf
			V.Global.bMove.Set(False)
			F.Data.DataView.Close("dtFullNest", "dvCheck")
			F.Data.Dataview.Close("dtProfile", "dvProfile")
			F.Data.DataTable.Close("dtFullNest")
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
	F.Intrinsic.Control.EndIf
	
	'get bin settings
	F.Data.Dictionary.CreateFromSQL("dictBin","Con","SELECT RTRIM(PART) + RTRIM(LOCATION) AS PARTLoc, RTRIM(BIN) AS BIN FROM V_INVENTORY_MSTR Order by Part")
	F.Data.Dictionary.SetDefaultReturn("dictBin","")
	F.Data.DataTable.AddColumn("dtFullNest", "BIN", "String")
	F.Intrinsic.control.If(V.DataView.dtProfile!dvProfile(0).DEFAULT_BIN_INV!FieldVal)
		F.Data.DataTable.FillFromDictionary("dtFullNest", "dictBin", "SHEET_MATERIAL", "BIN")
	F.Intrinsic.Control.ElseIf(V.DataView.dtProfile!dvProfile(0).MANUAL_BIN!FieldVal)
		F.Data.DataTable.SetValue("dtFullNest", -1,"BIN", V.DataView.dtProfile!dvProfile(0).MANUAL_BIN_ENTRY!FieldVal)
	F.Intrinsic.Control.EndIf
	F.Data.Dictionary.Close("dictBin")
	
	'get GSS Area and weight
	F.Data.DataView.Create("dtFullNest", "dvToString", 22)
	F.Data.DataView.ToString("dtFullNest", "dvToString", "SHEET_MATERIAL", "*!*", "','", V.Local.sSheetPartNumbers)
	F.Data.DataView.Close("dtFullNest", "dvToString")
	
	'need to figure out what to do with this based on option
	F.Global.General.ReadOption(400369, 0, False, V.Local.bInches)
	F.Intrinsic.Control.If(V.Local.bInches)
		F.Intrinsic.String.Build("select RTRIM(PART) as PART, RTRIM(PART) + RTRIM(LOCATION) as PARTLOC, If(LENGTH = 0, LENGTH_RAW_MATL, LENGTH) as LENGTH, IF(WIDTH = 0, WIDTH_RAW_MATL, WIDTH) as WIDTH, LBS as WEIGHT from V_INVENTORY_ALL where PART in ('{0}')", V.Local.sSheetPartNumbers, V.Local.sSQL)
	F.Intrinsic.Control.Else
		F.Intrinsic.String.Build("select RTRIM(PART) as PART, RTRIM(PART) + RTRIM(LOCATION) as PARTLOC, If(LENGTH = 0, LENGTH_RAW_MATL, LENGTH) * 12 as LENGTH, IF(WIDTH = 0, WIDTH_RAW_MATL, WIDTH) * 12 as WIDTH, LBS as WEIGHT from V_INVENTORY_ALL where PART in ('{0}')", V.Local.sSheetPartNumbers, V.Local.sSQL)
	F.Intrinsic.Control.EndIf
	
	F.Data.DataTable.CreateFromSQL("dtDimensions", "Con", V.Local.sSQL)
	
	'length
	F.Data.Dictionary.CreateFromDataTable("dictLength", "dtDimensions", "PARTLOC", "LENGTH")
	F.Data.Dictionary.SetDefaultReturn("dictLength", 0)
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictLength", "MATERIAL_AND_LOCATION", "GS_SHEET_LENGTH")
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictLength", "PART_AND_LOCATION", "GS_PART_LENGTH")
	F.Data.Dictionary.Close("dictLength")
	
	'width
	F.Data.Dictionary.CreateFromDataTable("dictWidth", "dtDimensions", "PARTLOC", "WIDTH")
	F.Data.Dictionary.SetDefaultReturn("dictWidth", 0)
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWidth", "MATERIAL_AND_LOCATION", "GS_SHEET_WIDTH")
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWidth", "PART_AND_LOCATION", "GS_PART_WIDTH")
	F.Data.Dictionary.Close("dictWidth")
	
	'weight
	F.Data.Dictionary.CreateFromDataTable("dictWeight", "dtDimensions", "PARTLOC", "WEIGHT")
	F.Data.Dictionary.SetDefaultReturn("dictWeight", 0)
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWeight", "MATERIAL_AND_LOCATION", "GS_SHEET_WEIGHT")
	F.Data.DataTable.FillFromDictionary("dtFullNest", "dictWeight", "PART_AND_LOCATION", "GS_PART_WEIGHT")
	F.Data.Dictionary.Close("dictWeight")
	
	F.Data.DataTable.Close("dtDimensions")
F.Intrinsic.Control.EndIf

'calculate area
F.Data.DataTable.AddExpressionColumn("dtFullNest", "GS_SHEET_AREA", "Float", "[GS_SHEET_WIDTH] * [GS_SHEET_LENGTH]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "GS_PART_AREA", "Float", "[GS_PART_WIDTH] * [GS_PART_LENGTH]")

'if no measurement from file, use measurement from GS
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FINAL_SHEET_AREA", "Float", "IIF([SHEET_AREA_SQUARE_INCHES] = 0, [GS_SHEET_AREA], [SHEET_AREA_SQUARE_INCHES])")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FINAL_PART_AREA", "Float", "IIF([PART_AREA_SQUARE_INCHES] = 0, [GS_PART_AREA], [PART_AREA_SQUARE_INCHES])")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FINAL_SHEET_WEIGHT", "Float", "IIF([SHEET_WEIGHT_POUNDS] = 0, [GS_SHEET_WEIGHT], [SHEET_WEIGHT_POUNDS])")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FINAL_PART_WEIGHT", "Float", "IIF([PART_WEIGHT_POUNDS] = 0, [GS_PART_WEIGHT], [PART_WEIGHT_POUNDS])")

F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "IMPORT_OPTION", "SETTING", "ALLOW_ZERO_MATERIAL", "PROFILE", V.Args.PROFILE)
F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
	V.Local.bAllowZeroMaterial.Set(V.Args.Setting.Trim)
F.Intrinsic.Control.Else
	V.Local.bAllowZeroMaterial.Set(False)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.If(V.Local.bIssueMaterial)
	F.Intrinsic.Control.If(V.Local.bAllowZeroMaterial.Not)
		'check if any part has 0 area
		F.Data.DataView.Create("dtFullNest","dvAreaCheck",22,"([FINAL_PART_AREA] = 0 or [FINAL_SHEET_AREA] = 0) and ([FINAL_SHEET_WEIGHT] = 0 or [FINAL_PART_WEIGHT] = 0)","")
		F.Intrinsic.Control.If(V.DataView.dtFullNest!dvAreaCheck.RowCount, =, V.DataTable.dtFullNest.RowCount)
			'part has 0 area, this file is no good
			F.Intrinsic.String.Build("{0}\MissingArea", V.Local.sImportPath, V.Local.sNewPath)
			F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sImportFile, "NEW_PATH", V.Local.sNewPath)
			F.Intrinsic.Control.If(V.Local.sSecondFile, !=, "")
				F.Intrinsic.Control.CallSub(MoveFile, "FILE", V.Local.sSecondFile, "NEW_PATH", V.Local.sNewPath)
			F.Intrinsic.Control.EndIf
			
			V.Global.bMove.Set(False)
			F.Data.DataView.Close("dtFullNest", "dvAreaCheck")
			F.Data.DataTable.Close("dtFullNest")
			F.Data.Dataview.Close("dtProfile", "dvProfile")
			
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.Else
			'set valid flag for later
			F.Data.DataView.SetValue("dtFullNest", "dvAreaCheck", -1, "VALID", "N")
			
			'output bad records
			F.Data.DataView.ToString("dtFullNest", "dvAreaCheck", V.DataTable.dtFullNest.FieldNames, ",", V.Ambient.NewLine, V.Local.sContents)
			F.Intrinsic.String.Replace(V.DataTable.dtFullNest.FieldNames, "*!*", ",", V.Local.sHeaders)
			F.Intrinsic.String.Build("{0}{1}{2}", V.Local.sHeaders, V.Ambient.NewLine, V.Local.sContents, V.Local.sContents)
			F.Intrinsic.File.GetFileNameFromFQN(V.Local.sImportFile, V.Local.sNewPath)
			F.Intrinsic.File.GetExtensionComponent(V.Local.sNewPath, V.Local.sExtension)
			F.Intrinsic.String.Build(".{0}", V.Local.sExtension, V.Local.sExtension)
			F.Intrinsic.String.Replace(V.Local.sNewPath, V.Local.sExtension, "", V.Local.sNewPath)
			F.Intrinsic.String.Build("{0}\MissingArea\{1}_INVALID_RECORDS_{2}.csv", V.Local.sImportPath, V.Local.sNewPath, V.Ambient.Now.FormatYYYY-MM-DD-HH-NN-SS, V.Local.sNewPath)
			F.Intrinsic.File.String2File(V.Local.sNewPath, V.Local.sContents)
		F.Intrinsic.Control.EndIf
		F.Data.DataView.Close("dtFullNest", "dvAreaCheck")
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.EndIf

'total calculations
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_GOOD_PIECES", "Float", "[RUN_COUNT] * [GOOD_PIECES]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_BAD_PIECES", "Float", "[RUN_COUNT] * [BAD_PIECES]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_PARTS", "Float", "[TOTAL_GOOD_PIECES] + [TOTAL_BAD_PIECES]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_SHEET_AREA", "Float", "[FINAL_SHEET_AREA] * [SHEET_COUNT]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_PART_AREA", "Float", "[TOTAL_PARTS] * [FINAL_PART_AREA]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_PART_WEIGHT", "Float", "[TOTAL_PARTS] * [FINAL_PART_WEIGHT]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_SHEET_WEIGHT", "Float", "[SHEET_COUNT] * [FINAL_SHEET_WEIGHT]")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_SHEET_WEIGHT_USAGE", "Float", "IIF([TOTAL_SHEET_WEIGHT] = 0, [TOTAL_PART_WEIGHT], [TOTAL_SHEET_WEIGHT])")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_MATERIAL", "Float", "IIF([SHEET_UM] = 'LB', [TOTAL_SHEET_WEIGHT_USAGE], [TOTAL_SHEET_AREA])")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "FINAL_TOTAL_TIME", "Float", "[TOTAL_TIME_HOURS] * [RUN_COUNT]")

'this won't work because there could be multiple nests in the file, so we need to loop
'F.Data.DataTable.AddExpressionColumn("dtFullNest", "TOTAL_TOTAL_PART_AREA", "Float", "SUM(TOTAL_PART_AREA)")
F.Data.DataTable.AddColumn("dtFullNest", "TOTAL_TOTAL_PART_AREA", "Float", 0)
F.Data.DataView.Create("dtFullNest", "dvFullNest", 22)
F.Data.DataView.ToString("dtFullNest", "dvFullNest", "NEST_ID", "***NO-DELIMITER***", "*!*", V.Local.sNests)
F.Intrinsic.String.Split(V.Local.sNests, "*!*", V.Local.sNests)
F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sNests, V.Local.sNests)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sNests.UBound, 1)
	F.Intrinsic.String.Build("[NEST_ID] = '{0}'", V.Local.sNests(V.Local.iCounter), V.Local.sFilter)
	
	'part area
	F.Data.DataTable.Compute("dtFullNest", "SUM(TOTAL_PART_AREA)", V.Local.sFilter, V.Local.fSum)
	F.Data.DataView.SetFilter("dtFullNest", "dvFullNest", V.Local.sFilter)
	F.Data.DataView.SetValue("dtFullNest", "dvFullNest", -1, "TOTAL_TOTAL_PART_AREA", V.Local.fSum)
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Data.DataView.Close("dtFullNest", "dvFullNest")
V.Local.sNests.Redim(0, 0)

'everything is coming in in square inches, convert it to what it needs to be
F.Data.DataTable.AddExpressionColumn("dtFullNest", "PART_ISSUE", "Float", "IIF([SHEET_UM] = 'SI' or [SHEET_UM] = 'SQ',[TOTAL_PART_AREA],IIF([SHEET_UM] = 'SF',[TOTAL_PART_AREA]/144, IIF([SHEET_UM] = 'SM',[TOTAL_PART_AREA]*0.00064516,IIF([SHEET_UM] = 'EA' or [SHEET_UM] = 'SH', IIF([FINAL_SHEET_AREA] = 0, 0, [TOTAL_PART_AREA]/[FINAL_SHEET_AREA]), IIF([SHEET_UM] = 'LB', [TOTAL_PART_WEIGHT], IIF([SHEET_UM] = 'SC', [TOTAL_PART_AREA] * 6.4516, IIF([SHEET_UM] = 'SN', [TOTAL_PART_AREA] * 645.16, 0)))))))")
F.Data.DataTable.AddExpressionColumn("dtFullNest", "SHEET_TOTAL_ISSUE", "Float", "IIF([SHEET_UM] = 'SI' or [SHEET_UM] = 'SQ', [TOTAL_SHEET_AREA], IIF([SHEET_UM] = 'SF', [TOTAL_SHEET_AREA]/144, IIF([SHEET_UM] = 'SM', [TOTAL_SHEET_AREA]*0.00064516, IIF([SHEET_UM] = 'EA' or [SHEET_UM] = 'SH', IIF([FINAL_SHEET_AREA] = 0, 0, [TOTAL_SHEET_AREA]/[FINAL_SHEET_AREA]), IIF([SHEET_UM] = 'LB', [TOTAL_SHEET_WEIGHT_USAGE], IIF([SHEET_UM] = 'SC', [TOTAL_SHEET_AREA] * 6.4516, IIF([SHEET_UM] = 'SN', [TOTAL_SHEET_AREA] * 645.16, 0)))))))")

'check if employee is valid
F.Data.Dictionary.CreateFromSQL("dictEmployee", "Con", "select RTRIM(EMPLOYEE), RTRIM(EMPLOYEE) from V_EMPLOYEE_MSTR where DATE_TERMINATION = '1900-01-01' and PAY_TYPE <> 'S'")
F.Data.Dictionary.SetDefaultReturn("dictEmployee", "")
F.Data.DataTable.AddColumn("dtFullNest", "CHECKED_EMPLOYEE", "String", "")
F.Data.DataTable.FillFromDictionary("dtFullNest", "dictEmployee", "EMPLOYEE", "CHECKED_EMPLOYEE")
F.Data.Dictionary.Close("dictEmployee")

F.Intrinsic.Control.If(V.Local.bIssueMaterial)
	F.Data.DataView.SetFilter("dtFullNest", "dvCheck", "[SHEET_UM] <> '' and VALID = 'Y'")
F.Intrinsic.Control.Else
	F.Data.DataView.SetFilter("dtFullNest", "dvCheck", "VALID = 'Y'")
F.Intrinsic.Control.EndIf

F.Data.DataView.ToDataTable("dtFullNest", "dvCheck", "dtValidNests")
F.Data.DataView.Close("dtFullNest", "dvCheck")
F.Data.DataTable.Close("dtFullNest")

'static columns
F.Data.DataTable.AddColumn("dtValidNests", "CLOSED", "String", "N")
F.Data.DataTable.AddColumn("dtValidNests", "READY_FLAG", "String", "Y")
F.Data.DataTable.AddColumn("dtValidNests", "RECORD_ID", "Integer")
F.Data.DataTable.SetSeries("dtValidNests", "RECORD_ID", 0, 1)
F.Data.DataTable.AddColumn("dtValidNests", "PROFILE", "String", V.Local.sProfile)

'if getting explicit issue amount from file, use that
F.Data.DataTable.SetValueFormat("dtValidNests", -1, "WORK_ORDER_MATERIAL_USED", "WORK_ORDER_MATERIAL_USED", "0.0000")
F.Data.DataTable.AddExpressionColumn("dtValidNests", "FINAL_ISSUE", "Float", "IIF([WORK_ORDER_MATERIAL_USED] = 0, [PART_ISSUE], [WORK_ORDER_MATERIAL_USED])")

'final single sheet measurement (area or weight)
F.Data.DataTable.AddExpressionColumn("dtValidNests", "FINAL_SINGLE_SHEET_MEASUREMENT", "Float", "IIF([SHEET_UM] = 'LB', [SHEET_WEIGHT_POUNDS], [FINAL_SHEET_AREA])")

'cut down nest id
F.Data.DataTable.AddExpressionColumn("dtValidNests", "FINAL_NEST_ID", "String", "SUBSTRING(NEST_ID, 1, 40)")

'calculate nest total issue
F.Data.DataView.Create("dtValidNests", "dvValidNests", 22)
F.Data.DataView.ToDataTableDistinct("dtValidNests", "dvValidNests", "dtNestIDs", "FINAL_NEST_ID")
F.Data.DataTable.AddColumn("dtValidNests", "NEST_TOTAL_MATERIAL_USAGE", Float, 0)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtNestIDs.RowCount--, 1)
	F.Intrinsic.String.Build("FINAL_NEST_ID = '{0}'", V.DataTable.dtNestIDs(V.Local.iCounter).FINAL_NEST_ID!FieldValTrim, V.Local.sFilter)
	F.Data.DataTable.Compute("dtValidNests", "SUM(FINAL_ISSUE)", V.Local.sFilter, V.Local.fSum)
	
	F.Data.DataView.SetFilter("dtValidNests", "dvValidNests", V.Local.sFilter)
	F.Data.DataView.SetValue("dtValidNests", "dvValidNests", -1, "NEST_TOTAL_MATERIAL_USAGE", V.Local.fSum)
F.Intrinsic.Control.Next(V.Local.iCounter)
F.Data.DataTable.Close("dtNestIDs")
F.Data.DataView.SetFilter("dtValidNests", "dvValidNests", "")
F.Data.DataTable.AddExpressionColumn("dtValidNests", "SHEET_TOTAL_ISSUE_FINAL", Float, "IIF([NEST_TOTAL_MATERIAL_USAGE] = 0, 0, [SHEET_TOTAL_ISSUE])")

'make sure we only have one record per material
F.Data.DataView.ToDataTableDistinct("dtValidNests", "dvValidNests", "dtValidMat", "FINAL_NEST_ID*!*SHEET_MATERIAL*!*SHEET_LOCATION*!*PROFILE*!*CLOSED*!*READY_FLAG*!*SHEET_COUNT*!*SHEET_TOTAL_ISSUE_FINAL*!*FINAL_SINGLE_SHEET_MEASUREMENT*!*SHEET_UM*!*TOTAL_MATERIAL*!*FINAL_SHEET_AREA*!*SHEET_WEIGHT_POUNDS")
F.Data.DataView.Close("dtValidNests", "dvValidNests")

'readd new record ID for mat table
F.Data.DataTable.AddColumn("dtValidMat", "RECORD_ID", "Integer")
F.Data.DataTable.SetSeries("dtValidMat", "RECORD_ID", 0, 1)

'clear old nests with the same ID
F.Intrinsic.Control.If(V.Local.bAppend.Not)
	'get nest id filter
	F.Data.DataView.Create("dtValidMat", "dvValidMat", 22)
	F.Data.DataView.ToString("dtValidMat", "dvValidMat", "FINAL_NEST_ID", "***NODELIMITER***", "','", V.Local.sFilter)
	F.Data.DataView.Close("dtValidMat", "dvValidMat")
	F.Intrinsic.String.Split(V.Local.sFilter, "','", V.Local.sFilter)
	F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sFilter, V.Local.sFilter)
	F.Intrinsic.String.Join(V.Local.sFilter, "','", V.Local.sFilter)
	
	F.Intrinsic.String.Build("Delete From GCG_4980_DROP Where NESTID in ('{0}');", V.Local.sFilter, V.Local.sSQL)
	F.ODBC.Connection!Con.Execute(V.Local.sSQL)
	F.Intrinsic.String.Build("Delete From GCG_4980_WO Where NESTID in ('{0}');", V.Local.sFilter, V.Local.sSQL)
	F.ODBC.Connection!Con.Execute(V.Local.sSQL)
	F.Intrinsic.String.Build("Delete From GCG_4980_MAT Where NESTID in ('{0}');", V.Local.sFilter, V.Local.sSQL)
	F.ODBC.Connection!Con.Execute(V.Local.sSQL)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.If(V.Local.bIssueMaterial.Not)
	F.Data.DataTable.SetValue("dtValidMat", -1, "SHEET_MATERIAL", "")
	F.Data.DataTable.SetValue("dtValidMat", -1, "SHEET_LOCATION", "")
	F.Data.DataTable.SetValue("dtValidNests", -1, "SHEET_MATERIAL", "")
	F.Data.DataTable.SetValue("dtValidNests", -1, "SHEET_LOCATION", "")
F.Intrinsic.Control.EndIf

'save to the MAT and WO tables
F.Data.DataTable.SaveToDB("dtValidMat", "Con", "GCG_4980_MAT", "", 128, "FINAL_NEST_ID@!@NESTID*!*RECORD_ID@!@ID*!*SHEET_MATERIAL@!@MATERIAL*!*SHEET_LOCATION@!@LOC*!*PROFILE@!@PROFILE*!*TOTAL_MATERIAL@!@QTY*!*FINAL_SINGLE_SHEET_MEASUREMENT@!@AREA*!*CLOSED@!@CLOSED*!*READY_FLAG@!@READY_FLAG*!*SHEET_TOTAL_ISSUE_FINAL@!@ISSUE*!*SHEET_UM@!@UM*!*FINAL_SHEET_AREA@!@SHEET_AREA*!*SHEET_WEIGHT_POUNDS@!@SHEET_WEIGHT")
F.Data.DataTable.Close("dtValidMat")

F.Data.DataTable.SaveToDB("dtValidNests", "Con", "GCG_4980_WO", "", 128, "FINAL_NEST_ID@!@NESTID*!*RECORD_ID@!@ID*!*CHECKED_EMPLOYEE@!@EMPLOYEE*!*FULL_JOB@!@TJOB*!*FINAL_TOTAL_TIME@!@TIME*!*SHEET_MATERIAL@!@MATERIAL*!*SHEET_LOCATION@!@LOC*!*TOTAL_PARTS@!@QTY*!*TOTAL_GOOD_PIECES@!@GOOD_PC*!*TOTAL_BAD_PIECES@!@BAD_PC*!*JOB@!@JOB*!*SUFFIX@!@SUFFIX*!*SEQUENCE@!@SEQUENCE*!*BIN@!@BIN*!*FINAL_ISSUE@!@ISSUE*!*FINAL_WC@!@WC*!*READY_FLAG@!@READY_FLAG*!*RUN_COUNT@!@RUN_COUNT*!*FILE@!@FILE*!*FINAL_PART_AREA@!@PART_AREA*!*FINAL_PART_WEIGHT@!@PART_WEIGHT")

'now process drops
F.Intrinsic.Control.If(V.Local.bImportDrops)
	F.Data.DataTable.AddExpressionColumn("dtDrops", "FINAL_NEST_ID", "String", "SUBSTRING(NEST_ID, 1, 40)")
	
	'add necessary columns
	F.Data.Linq.Join("LeftJoin", "DataTable", "dtDrops*!*A", "DataTable", "dtValidNests*!*B", "A.FINAL_NEST_ID = B.FINAL_NEST_ID", "A.FINAL_NEST_ID*!*A.DROP_ID*!*A.DROP_LENGTH_INCHES*!*A.DROP_WIDTH_INCHES*!*A.DROP_WEIGHT_POUNDS*!*B.SHEET_MATERIAL*!*B.SHEET_UM*!*B.FINAL_SHEET_AREA*!*B.CLOSED*!*B.SHEET_LOCATION", "", "", "", "dtFullDrops", False)
	
	F.Data.DataView.Create("dtFullDrops", "dvFullDrops", 22)
	F.Data.DataView.ToDataTableDistinct("dtFullDrops", "dvFullDrops", "dtValidDrops", "FINAL_NEST_ID*!*DROP_ID*!*DROP_LENGTH_INCHES*!*DROP_WIDTH_INCHES*!*DROP_WEIGHT_POUNDS*!*SHEET_MATERIAL*!*SHEET_UM*!*FINAL_SHEET_AREA*!*CLOSED*!*SHEET_LOCATION")
	F.Data.DataView.Close("dtFullDrops", "dvFullDrops")
	F.Data.DataTable.Close("dtFullDrops")
	
	F.Data.DataTable.AddColumn("dtValidDrops", "DROP_BIN", "STRING", V.DataView.dtProfile!dvProfile(0).REM_BIN_ENTRY!FieldValTrim)
	F.Data.DataTable.AddColumn("dtValidDrops", "RECORD_ID", "Long")
	
	F.Data.DataTable.SetSeries("dtValidDrops", "RECORD_ID", 0, 1)
	
	'calculate area, issue (based on UM), and SIZE Field
	F.Data.DataTable.AddExpressionColumn("dtValidDrops", "DROP_AREA", "FLOAT", "[DROP_LENGTH_INCHES] * [DROP_WIDTH_INCHES]")
	F.Data.DataTable.AddExpressionColumn("dtValidDrops", "DROP_ISSUE", "Float", "IIF([SHEET_UM] = 'SI' or [SHEET_UM] = 'SQ', [DROP_AREA], IIF([SHEET_UM] = 'SF', [DROP_AREA]/144, IIF([SHEET_UM] = 'SM', [DROP_AREA]*0.00064516, IIF([SHEET_UM] = 'EA' or [SHEET_UM] = 'SH', IIF([FINAL_SHEET_AREA] = 0, 0, [DROP_AREA]/[FINAL_SHEET_AREA]), IIF([SHEET_UM] = 'LB', [DROP_WEIGHT_POUNDS], 0)))))")
	
	F.Data.DataTable.AddExpressionColumn("dtValidDrops", "DROP_SIZE", "STRING", "[DROP_LENGTH_INCHES] + 'X' + [DROP_WIDTH_INCHES]")
	
	'grab serial option
	F.Intrinsic.Control.CallSub(GetSetting, "TYPE", "REMNANT_OPTION", "SETTING", "STORE_SIZE_IN_SERIAL", "PROFILE", V.Args.PROFILE)
	F.Intrinsic.Control.If(V.Args.Setting.Trim, !=, "")
		V.Local.bUseSerialForSize.Set(V.Args.Setting)
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Control.If(V.Local.bUseSerialForSize)
		V.Local.sExpression.Set("[DROP_ID]")
	F.Intrinsic.Control.Else
		V.Local.sExpression.Set("[DROP_SIZE]")
	F.Intrinsic.Control.EndIf
	F.Data.DataTable.AddExpressionColumn("dtValidDrops", "FINAL_SERIAL", "String", V.Local.sExpression)
	
	F.Data.DataTable.SaveToDB("dtValidDrops","Con","GCG_4980_DROP","", 128,"FINAL_NEST_ID@!@NESTID*!*RECORD_ID@!@ID*!*SHEET_MATERIAL@!@MATERIAL*!*SHEET_LOCATION@!@LOC*!*DROP_AREA@!@QTY*!*FINAL_SERIAL@!@SERIAL*!*DROP_SIZE@!@SIZE*!*DROP_BIN@!@BIN*!*SHEET_UM@!@UM*!*DROP_ISSUE@!@DROP_ISSUE*!*CLOSED@!@CLOSED*!*DROP_ID@!@DROP_ID*!*DROP_AREA@!@DROP_AREA*!*DROP_WEIGHT_POUNDS@!@DROP_WEIGHT")
	
	F.Data.DataTable.Close("dtValidDrops")
F.Intrinsic.Control.EndIf

F.Data.DataTable.Close("dtDrops")
F.Data.DataTable.Close("dtValidNests")
F.Data.Dataview.Close("dtProfile","dvProfile")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.Import.End

Program.Sub.Exit.Start
F.Intrinsic.Control.Try

F.Intrinsic.Control.CallSub(CloseSettingsDT)

F.Intrinsic.Control.CallSub(ScriptPIDClear, "PROJECT", "4980", "TASK", "Import")
F.ODBC.Connection!Con.Close
F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.Exit.End

Program.Sub.AddExtraImportFields.Start
F.Intrinsic.Control.Try

V.Local.sSQL.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.sExpression.Declare(String)
V.Local.sValue.Declare(String)

'grab any static / expression import fields
F.Intrinsic.String.Build("select RTRIM(SETTING) FIELD, RTRIM(VALUE) VALUE, IF(SUBSTRING(SETTING, 1, 2) = 'ST', 'STATIC', 'EXPRESSION') TYPE from GCG_4980_SETTINGS A where PROFILE = '{0}' and A.TYPE = 'IMPORT_FIELD'", V.Args.Profile.Trim, V.Local.sSQL)

F.Data.DataTable.CreateFromSQL("dtExtraFields", "Con", V.Local.sSQL)
F.Intrinsic.Control.If(V.DataTable.dtExtraFields.RowCount, <, 1)
	F.Data.DataTable.Close("dtExtraFields")
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'add them to the passed datatable
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtExtraFields.RowCount--, 1)
	F.Intrinsic.String.Split(V.DataTable.dtExtraFields(V.Local.iCounter).VALUE!FieldValTrim, "@*!*@", V.Local.sValue)
	F.Intrinsic.Control.If(V.DataTable.dtExtraFields(V.Local.iCounter).TYPE!FieldValTrim, =, "STATIC")
		F.Data.DataTable.AddColumn(V.Args.DataTable, V.DataTable.dtExtraFields(V.Local.iCounter).FIELD!FieldValTrim, "String", V.Local.sValue(0))
	F.Intrinsic.Control.ElseIf(V.DataTable.dtExtraFields(V.Local.iCounter).TYPE!FieldValTrim, =, "EXPRESSION")
		F.Intrinsic.String.Build("Convert({0}, 'System.String')", V.Local.sValue(0), V.Local.sExpression)
		F.Data.DataTable.AddExpressionColumn(V.Args.DataTable, V.DataTable.dtExtraFields(V.Local.iCounter).FIELD!FieldValTrim, "String", V.Local.sExpression)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)

F.Data.DataTable.Close("dtExtraFields")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.AddExtraImportFields.End

Program.Sub.SumFieldByKey.Start
'pass DataTable, Source, Target, Key

F.Intrinsic.Control.Try

V.Local.sFilter.Declare(String)
V.Local.sKeys.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.fSum.Declare(Float)
V.Local.sExpression.Declare(String)

F.Data.DataView.Create(V.Args.DataTable, "dvSumFieldByKey", 22)

'get unqiue key list
F.Data.DataView.ToString(V.Args.DataTable, "dvSumFieldByKey", V.Args.Key, "***NO-DELIMITER***", "*!*", V.Local.sKeys)
F.Intrinsic.String.Split(V.Local.sKeys, "*!*", V.Local.sKeys)
F.Intrinsic.String.RemoveArrayDuplicates(V.Local.sKeys, V.Local.sKeys)

'build expression
F.Intrinsic.String.Build("SUM({0})", V.Args.Source, V.Local.sExpression)

'loop through and sum
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sKeys.UBound, 1)
	F.Intrinsic.String.Build("[{0}] = '{1}'", V.Args.Key, V.Local.sKeys(V.Local.iCounter), V.Local.sFilter)
	F.Data.DataTable.Compute(V.Args.DataTable, V.Local.sExpression, V.Local.sFilter, V.Local.fSum)
	F.Data.DataView.SetFilter(V.Args.DataTable, "dvSumFieldByKey", V.Local.sFilter)
	F.Data.DataView.SetValue(V.Args.DataTable, "dvSumFieldByKey", -1, V.Args.Target, V.Local.fSum)
F.Intrinsic.Control.Next(V.Local.iCounter)
V.Local.sKeys.Redim(0, 0)

F.Data.DataView.Close(V.Args.DataTable, "dvSumFieldByKey")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.SumFieldByKey.End

Program.Sub.GroupNest.Start
'group all individual nestIDs by file if possible
'check for materials
'pass FILE

F.Intrinsic.Control.Try

V.Local.sFileName.Declare(String)
V.Local.iMaterialCounter.Declare(Long)
V.Local.iCounter.Declare(Long)
V.Local.sFilter.Declare(String)
V.Local.iSum.Declare(Long)
V.Local.sNestID.Declare(String)
V.Local.sExtension.Declare(String)
V.Local.iJ.Declare(Long)

'get filename
F.Intrinsic.File.GetFileNameFromFQN(V.Args.File, V.Local.sFileName)
F.Intrinsic.File.GetExtensionComponent(V.Local.sFileName, V.Local.sExtension)
F.Intrinsic.String.Build(".{0}", V.Local.sExtension, V.Local.sExtension)
F.Intrinsic.String.Replace(V.Local.sFileName, V.Local.sExtension, "", V.Local.sFileName)

'not sure if sheet area or weight will matter here
F.Data.DataView.Create("dtMaterial", "dvMaterial", 22)
F.Data.DataView.ToDataTableDistinct("dtMaterial", "dvMaterial", "dtDistinctMaterial", "SHEET_MATERIAL*!*SHEET_LOCATION*!*SHEET_AREA_SQUARE_INCHES*!*SHEET_WEIGHT_POUNDS", "")
F.Data.DataTable.AddColumn("dtDistinctMaterial", "NEST_ID", "String", "")
F.Data.DataTable.AddColumn("dtDistinctMaterial", "SHEET_COUNT", "Long", 0)

F.Data.DataView.Create("dtWorkOrders", "dvWorkOrders", 22)
F.Data.DataView.Create("dtDrops", "dvDrops", 22)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.DataTable.dtDistinctMaterial.RowCount--, 1)
	
	'create nest ID
	F.Intrinsic.Control.If(V.Local.iCounter, =, 0)
		V.Local.sNestID.Set(V.Local.sFileName)
	F.Intrinsic.Control.Else
		F.Intrinsic.String.Build("{0}_{1}", V.Local.sFileName, V.Local.iCounter, V.Local.sNestID)
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.String.Build("SHEET_MATERIAL = '{0}' and SHEET_LOCATION = '{1}' and SHEET_AREA_SQUARE_INCHES = {2} and SHEET_WEIGHT_POUNDS = {3}", V.DataTable.dtDistinctMaterial(V.Local.iCounter).SHEET_MATERIAL!FieldValTrim, V.DataTable.dtDistinctMaterial(V.Local.iCounter).SHEET_LOCATION!FieldValTrim, V.DataTable.dtDistinctMaterial(V.Local.iCounter).SHEET_AREA_SQUARE_INCHES!FieldValFloat, V.DataTable.dtDistinctMaterial(V.Local.iCounter).SHEET_WEIGHT_POUNDS!FieldValFloat, V.Local.sFilter)
	
	'area, weight should be the same, so we need to get count
	F.Data.DataTable.Compute("dtMaterial", "SUM(SHEET_COUNT)", V.Local.sFilter, V.Local.iSum)
	
	F.Data.DataView.SetFilter("dtMaterial", "dvMaterial", V.Local.sFilter)
	
	'set the new values in the distinct datatable
	F.Data.DataTable.SetValue("dtDistinctMaterial", V.Local.iCounter, "NEST_ID", V.Local.sNestID, "SHEET_COUNT", V.Local.iSum)

	'now fix the nest IDs in the work orders and drops datatable
	F.Intrinsic.Control.For(V.Local.iJ, 0, V.DataView.dtMaterial!dvMaterial.RowCount--, 1)
		F.Intrinsic.String.Build("NEST_ID = '{0}'", V.DataView.dtMaterial!dvMaterial(V.Local.iJ).NEST_ID!FieldValTrim, V.Local.sFilter)
		F.Data.DataView.SetFilter("dtWorkOrders", "dvWorkOrders", V.Local.sFilter)
		F.Data.DataView.SetValue("dtWorkOrders", "dvWorkOrders", -1, "NEST_ID", V.Local.sNestID)
		
		F.Data.DataView.SetFilter("dtDrops", "dvDrops", V.Local.sFilter)
		F.Data.DataView.SetValue("dtDrops", "dvDrops", -1, "NEST_ID", V.Local.sNestID)
	F.Intrinsic.Control.Next(V.Local.iJ)
F.Intrinsic.Control.Next(V.Local.iCounter)

F.Data.DataView.Close("dtMaterial", "dvMaterial")
F.Data.DataView.Close("dtWorkOrders", "dvWorkOrders")
F.Data.DataView.Close("dtDrops", "dvDrops")

'now, put the final values in the original material table
F.Data.DataTable.DeleteRow("dtMaterial")
F.Data.DataTable.Merge("dtDistinctMaterial", "dtMaterial", False, 2)
F.Data.DataTable.AcceptChanges("dtMaterial")

F.Data.DataTable.Close("dtDistinctMaterial")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(ErrorMessage, "ErrorNumber", V.Ambient.ErrorNumber, "ErrorDescription", V.Ambient.ErrorDescription, "Subroutine", V.Ambient.CurrentSubroutine, "Callback", "Exit", "UNATTENDED", V.Global.bUnattended, "PROJECT", "4980", "PROJECTTITLE", "Standard Nesting Interface", "Task", "Nest_Import")
F.Intrinsic.Control.EndTry
Program.Sub.GroupNest.End

Program.Sub.Comments.Start
${$5$}$2.0.0.0$}$2
${$6$}$rseddon$}$20240131140911241$}$DkKb6sybY9hE3N0enyRwKJuHSlMGTgRbD07HPEnmOmBwv1venTLa93K8HIJ4bV7uqIDi6wUzBxs=
Program.Sub.Comments.End